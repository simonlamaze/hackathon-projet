{
  "version": 3,
  "sources": ["../../chessground/src/types.ts", "../../chessground/src/util.ts", "../../chessground/src/premove.ts", "../../chessground/src/board.ts", "../../chessground/src/fen.ts", "../../chessground/src/config.ts", "../../chessground/src/anim.ts", "../../chessground/src/draw.ts", "../../chessground/src/drag.ts", "../../chessground/src/explosion.ts", "../../chessground/src/api.ts", "../../chessground/src/state.ts", "../../chessground/src/svg.ts", "../../chessground/src/wrap.ts", "../../chessground/src/drop.ts", "../../chessground/src/events.ts", "../../chessground/src/render.ts", "../../chessground/src/sync.ts", "../../chessground/src/autoPieces.ts", "../../chessground/src/chessground.ts"],
  "sourcesContent": ["export type Color = (typeof colors)[number];\nexport type Role = (typeof roles)[number];\nexport type File = (typeof files)[number];\nexport type Rank = (typeof ranks)[number];\nexport type Key = 'a0' | `${File}${Rank}`;\nexport type FEN = string;\nexport type Pos = [number, number];\nexport interface Piece {\n  role: Role;\n  color: Color;\n  promoted?: boolean;\n}\nexport interface Drop {\n  role: Role;\n  key: Key;\n}\nexport type Pieces = Map<Key, Piece>;\nexport type PiecesDiff = Map<Key, Piece | undefined>;\n\nexport type KeyPair = [Key, Key];\n\nexport type NumberPair = [number, number];\n\nexport type NumberQuad = [number, number, number, number];\n\nexport interface Rect {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n}\n\nexport type Dests = Map<Key, Key[]>;\n\nexport interface Elements {\n  board: HTMLElement;\n  wrap: HTMLElement;\n  container: HTMLElement;\n  ghost?: HTMLElement;\n  svg?: SVGElement;\n  customSvg?: SVGElement;\n  autoPieces?: HTMLElement;\n}\nexport interface Dom {\n  elements: Elements;\n  bounds: Memo<DOMRectReadOnly>;\n  redraw: () => void;\n  redrawNow: (skipSvg?: boolean) => void;\n  unbind?: Unbind;\n  destroyed?: boolean;\n}\nexport interface Exploding {\n  stage: number;\n  keys: readonly Key[];\n}\n\nexport interface MoveMetadata {\n  premove: boolean;\n  ctrlKey?: boolean;\n  holdTime?: number;\n  captured?: Piece;\n  predrop?: boolean;\n}\nexport interface SetPremoveMetadata {\n  ctrlKey?: boolean;\n}\n\nexport type MouchEvent = Event & Partial<MouseEvent & TouchEvent>;\n\nexport interface KeyedNode extends HTMLElement {\n  cgKey: Key;\n}\nexport interface PieceNode extends KeyedNode {\n  tagName: 'PIECE';\n  cgPiece: string;\n  cgAnimating?: boolean;\n  cgFading?: boolean;\n  cgDragging?: boolean;\n  cgScale?: number;\n}\nexport interface SquareNode extends KeyedNode {\n  tagName: 'SQUARE';\n}\n\nexport interface Memo<A> {\n  (): A;\n  clear: () => void;\n}\n\nexport interface Timer {\n  start: () => void;\n  cancel: () => void;\n  stop: () => number;\n}\n\nexport type Redraw = () => void;\nexport type Unbind = () => void;\nexport type Milliseconds = number;\nexport type KHz = number;\n\nexport const colors = ['white', 'black'] as const;\nexport const roles = ['pawn', 'knight', 'bishop', 'rook', 'queen', 'king'] as const;\nexport const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] as const;\nexport const ranks = ['1', '2', '3', '4', '5', '6', '7', '8'] as const;\n\nexport type RanksPosition = 'left' | 'right';\n\nexport type BrushColor = 'green' | 'red' | 'blue' | 'yellow';\n\nexport type SquareClasses = Map<Key, string>;\n", "import * as cg from './types.js';\n\nexport const invRanks: readonly cg.Rank[] = [...cg.ranks].reverse();\n\nexport const allKeys: readonly cg.Key[] = Array.prototype.concat(\n  ...cg.files.map(c => cg.ranks.map(r => c + r)),\n);\n\nexport const pos2key = (pos: cg.Pos): cg.Key => allKeys[8 * pos[0] + pos[1]];\n\nexport const key2pos = (k: cg.Key): cg.Pos => [k.charCodeAt(0) - 97, k.charCodeAt(1) - 49];\n\nexport const uciToMove = (uci: string | undefined): cg.Key[] | undefined => {\n  if (!uci) return undefined;\n  if (uci[1] === '@') return [uci.slice(2, 4) as cg.Key];\n  return [uci.slice(0, 2), uci.slice(2, 4)] as cg.Key[];\n};\n\nexport const allPos: readonly cg.Pos[] = allKeys.map(key2pos);\n\nexport function memo<A>(f: () => A): cg.Memo<A> {\n  let v: A | undefined;\n  const ret = (): A => {\n    if (v === undefined) v = f();\n    return v;\n  };\n  ret.clear = () => {\n    v = undefined;\n  };\n  return ret;\n}\n\nexport const timer = (): cg.Timer => {\n  let startAt: number | undefined;\n  return {\n    start() {\n      startAt = performance.now();\n    },\n    cancel() {\n      startAt = undefined;\n    },\n    stop() {\n      if (!startAt) return 0;\n      const time = performance.now() - startAt;\n      startAt = undefined;\n      return time;\n    },\n  };\n};\n\nexport const opposite = (c: cg.Color): cg.Color => (c === 'white' ? 'black' : 'white');\n\nexport const distanceSq = (pos1: cg.Pos, pos2: cg.Pos): number => {\n  const dx = pos1[0] - pos2[0],\n    dy = pos1[1] - pos2[1];\n  return dx * dx + dy * dy;\n};\n\nexport const samePiece = (p1: cg.Piece, p2: cg.Piece): boolean =>\n  p1.role === p2.role && p1.color === p2.color;\n\nexport const posToTranslate =\n  (bounds: DOMRectReadOnly): ((pos: cg.Pos, asWhite: boolean) => cg.NumberPair) =>\n  (pos, asWhite) => [\n    ((asWhite ? pos[0] : 7 - pos[0]) * bounds.width) / 8,\n    ((asWhite ? 7 - pos[1] : pos[1]) * bounds.height) / 8,\n  ];\n\nexport const translate = (el: HTMLElement, pos: cg.NumberPair): void => {\n  el.style.transform = `translate(${pos[0]}px,${pos[1]}px)`;\n};\n\nexport const translateAndScale = (el: HTMLElement, pos: cg.NumberPair, scale = 1): void => {\n  el.style.transform = `translate(${pos[0]}px,${pos[1]}px) scale(${scale})`;\n};\n\nexport const setVisible = (el: HTMLElement, v: boolean): void => {\n  el.style.visibility = v ? 'visible' : 'hidden';\n};\n\nexport const eventPosition = (e: cg.MouchEvent): cg.NumberPair | undefined => {\n  if (e.clientX || e.clientX === 0) return [e.clientX, e.clientY!];\n  if (e.targetTouches?.[0]) return [e.targetTouches[0].clientX, e.targetTouches[0].clientY];\n  return; // touchend has no position!\n};\n\nexport const isRightButton = (e: cg.MouchEvent): boolean => e.button === 2;\n\nexport const createEl = (tagName: string, className?: string): HTMLElement => {\n  const el = document.createElement(tagName);\n  if (className) el.className = className;\n  return el;\n};\n\nexport function computeSquareCenter(key: cg.Key, asWhite: boolean, bounds: DOMRectReadOnly): cg.NumberPair {\n  const pos = key2pos(key);\n  if (!asWhite) {\n    pos[0] = 7 - pos[0];\n    pos[1] = 7 - pos[1];\n  }\n  return [\n    bounds.left + (bounds.width * pos[0]) / 8 + bounds.width / 16,\n    bounds.top + (bounds.height * (7 - pos[1])) / 8 + bounds.height / 16,\n  ];\n}\n", "import * as util from './util.js';\nimport * as cg from './types.js';\n\ntype Mobility = (x1: number, y1: number, x2: number, y2: number) => boolean;\n\nconst diff = (a: number, b: number): number => Math.abs(a - b);\n\nconst pawn =\n  (color: cg.Color): Mobility =>\n  (x1, y1, x2, y2) =>\n    diff(x1, x2) < 2 &&\n    (color === 'white'\n      ? // allow 2 squares from first two ranks, for horde\n        y2 === y1 + 1 || (y1 <= 1 && y2 === y1 + 2 && x1 === x2)\n      : y2 === y1 - 1 || (y1 >= 6 && y2 === y1 - 2 && x1 === x2));\n\nexport const knight: Mobility = (x1, y1, x2, y2) => {\n  const xd = diff(x1, x2);\n  const yd = diff(y1, y2);\n  return (xd === 1 && yd === 2) || (xd === 2 && yd === 1);\n};\n\nconst bishop: Mobility = (x1, y1, x2, y2) => {\n  return diff(x1, x2) === diff(y1, y2);\n};\n\nconst rook: Mobility = (x1, y1, x2, y2) => {\n  return x1 === x2 || y1 === y2;\n};\n\nexport const queen: Mobility = (x1, y1, x2, y2) => {\n  return bishop(x1, y1, x2, y2) || rook(x1, y1, x2, y2);\n};\n\nconst king =\n  (color: cg.Color, rookFiles: number[], canCastle: boolean): Mobility =>\n  (x1, y1, x2, y2) =>\n    (diff(x1, x2) < 2 && diff(y1, y2) < 2) ||\n    (canCastle &&\n      y1 === y2 &&\n      y1 === (color === 'white' ? 0 : 7) &&\n      ((x1 === 4 && ((x2 === 2 && rookFiles.includes(0)) || (x2 === 6 && rookFiles.includes(7)))) ||\n        rookFiles.includes(x2)));\n\nfunction rookFilesOf(pieces: cg.Pieces, color: cg.Color) {\n  const backrank = color === 'white' ? '1' : '8';\n  const files = [];\n  for (const [key, piece] of pieces) {\n    if (key[1] === backrank && piece.color === color && piece.role === 'rook') {\n      files.push(util.key2pos(key)[0]);\n    }\n  }\n  return files;\n}\n\nexport function premove(pieces: cg.Pieces, key: cg.Key, canCastle: boolean): cg.Key[] {\n  const piece = pieces.get(key);\n  if (!piece) return [];\n  const pos = util.key2pos(key),\n    r = piece.role,\n    mobility: Mobility =\n      r === 'pawn'\n        ? pawn(piece.color)\n        : r === 'knight'\n          ? knight\n          : r === 'bishop'\n            ? bishop\n            : r === 'rook'\n              ? rook\n              : r === 'queen'\n                ? queen\n                : king(piece.color, rookFilesOf(pieces, piece.color), canCastle);\n  return util.allPos\n    .filter(pos2 => (pos[0] !== pos2[0] || pos[1] !== pos2[1]) && mobility(pos[0], pos[1], pos2[0], pos2[1]))\n    .map(util.pos2key);\n}\n", "import { HeadlessState } from './state.js';\nimport { pos2key, key2pos, opposite, distanceSq, allPos, computeSquareCenter } from './util.js';\nimport { premove, queen, knight } from './premove.js';\nimport * as cg from './types.js';\n\nexport function callUserFunction<T extends (...args: any[]) => void>(\n  f: T | undefined,\n  ...args: Parameters<T>\n): void {\n  if (f) setTimeout(() => f(...args), 1);\n}\n\nexport function toggleOrientation(state: HeadlessState): void {\n  state.orientation = opposite(state.orientation);\n  state.animation.current = state.draggable.current = state.selected = undefined;\n}\n\nexport function reset(state: HeadlessState): void {\n  state.lastMove = undefined;\n  unselect(state);\n  unsetPremove(state);\n  unsetPredrop(state);\n}\n\nexport function setPieces(state: HeadlessState, pieces: cg.PiecesDiff): void {\n  for (const [key, piece] of pieces) {\n    if (piece) state.pieces.set(key, piece);\n    else state.pieces.delete(key);\n  }\n}\n\nexport function setCheck(state: HeadlessState, color: cg.Color | boolean): void {\n  state.check = undefined;\n  if (color === true) color = state.turnColor;\n  if (color)\n    for (const [k, p] of state.pieces) {\n      if (p.role === 'king' && p.color === color) {\n        state.check = k;\n      }\n    }\n}\n\nfunction setPremove(state: HeadlessState, orig: cg.Key, dest: cg.Key, meta: cg.SetPremoveMetadata): void {\n  unsetPredrop(state);\n  state.premovable.current = [orig, dest];\n  callUserFunction(state.premovable.events.set, orig, dest, meta);\n}\n\nexport function unsetPremove(state: HeadlessState): void {\n  if (state.premovable.current) {\n    state.premovable.current = undefined;\n    callUserFunction(state.premovable.events.unset);\n  }\n}\n\nfunction setPredrop(state: HeadlessState, role: cg.Role, key: cg.Key): void {\n  unsetPremove(state);\n  state.predroppable.current = { role, key };\n  callUserFunction(state.predroppable.events.set, role, key);\n}\n\nexport function unsetPredrop(state: HeadlessState): void {\n  const pd = state.predroppable;\n  if (pd.current) {\n    pd.current = undefined;\n    callUserFunction(pd.events.unset);\n  }\n}\n\nfunction tryAutoCastle(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  if (!state.autoCastle) return false;\n\n  const king = state.pieces.get(orig);\n  if (!king || king.role !== 'king') return false;\n\n  const origPos = key2pos(orig);\n  const destPos = key2pos(dest);\n  if ((origPos[1] !== 0 && origPos[1] !== 7) || origPos[1] !== destPos[1]) return false;\n  if (origPos[0] === 4 && !state.pieces.has(dest)) {\n    if (destPos[0] === 6) dest = pos2key([7, destPos[1]]);\n    else if (destPos[0] === 2) dest = pos2key([0, destPos[1]]);\n  }\n  const rook = state.pieces.get(dest);\n  if (!rook || rook.color !== king.color || rook.role !== 'rook') return false;\n\n  state.pieces.delete(orig);\n  state.pieces.delete(dest);\n\n  if (origPos[0] < destPos[0]) {\n    state.pieces.set(pos2key([6, destPos[1]]), king);\n    state.pieces.set(pos2key([5, destPos[1]]), rook);\n  } else {\n    state.pieces.set(pos2key([2, destPos[1]]), king);\n    state.pieces.set(pos2key([3, destPos[1]]), rook);\n  }\n  return true;\n}\n\nexport function baseMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): cg.Piece | boolean {\n  const origPiece = state.pieces.get(orig),\n    destPiece = state.pieces.get(dest);\n  if (orig === dest || !origPiece) return false;\n  const captured = destPiece && destPiece.color !== origPiece.color ? destPiece : undefined;\n  if (dest === state.selected) unselect(state);\n  callUserFunction(state.events.move, orig, dest, captured);\n  if (!tryAutoCastle(state, orig, dest)) {\n    state.pieces.set(dest, origPiece);\n    state.pieces.delete(orig);\n  }\n  state.lastMove = [orig, dest];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  return captured || true;\n}\n\nexport function baseNewPiece(state: HeadlessState, piece: cg.Piece, key: cg.Key, force?: boolean): boolean {\n  if (state.pieces.has(key)) {\n    if (force) state.pieces.delete(key);\n    else return false;\n  }\n  callUserFunction(state.events.dropNewPiece, piece, key);\n  state.pieces.set(key, piece);\n  state.lastMove = [key];\n  state.check = undefined;\n  callUserFunction(state.events.change);\n  state.movable.dests = undefined;\n  state.turnColor = opposite(state.turnColor);\n  return true;\n}\n\nfunction baseUserMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): cg.Piece | boolean {\n  const result = baseMove(state, orig, dest);\n  if (result) {\n    state.movable.dests = undefined;\n    state.turnColor = opposite(state.turnColor);\n    state.animation.current = undefined;\n  }\n  return result;\n}\n\nexport function userMove(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const holdTime = state.hold.stop();\n      unselect(state);\n      const metadata: cg.MoveMetadata = {\n        premove: false,\n        ctrlKey: state.stats.ctrlKey,\n        holdTime,\n      };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      return true;\n    }\n  } else if (canPremove(state, orig, dest)) {\n    setPremove(state, orig, dest, {\n      ctrlKey: state.stats.ctrlKey,\n    });\n    unselect(state);\n    return true;\n  }\n  unselect(state);\n  return false;\n}\n\nexport function dropNewPiece(state: HeadlessState, orig: cg.Key, dest: cg.Key, force?: boolean): void {\n  const piece = state.pieces.get(orig);\n  if (piece && (canDrop(state, orig, dest) || force)) {\n    state.pieces.delete(orig);\n    baseNewPiece(state, piece, dest, force);\n    callUserFunction(state.movable.events.afterNewPiece, piece.role, dest, {\n      premove: false,\n      predrop: false,\n    });\n  } else if (piece && canPredrop(state, orig, dest)) {\n    setPredrop(state, piece.role, dest);\n  } else {\n    unsetPremove(state);\n    unsetPredrop(state);\n  }\n  state.pieces.delete(orig);\n  unselect(state);\n}\n\nexport function selectSquare(state: HeadlessState, key: cg.Key, force?: boolean): void {\n  callUserFunction(state.events.select, key);\n  if (state.selected) {\n    if (state.selected === key && !state.draggable.enabled) {\n      unselect(state);\n      state.hold.cancel();\n      return;\n    } else if ((state.selectable.enabled || force) && state.selected !== key) {\n      if (userMove(state, state.selected, key)) {\n        state.stats.dragged = false;\n        return;\n      }\n    }\n  }\n  if (\n    (state.selectable.enabled || state.draggable.enabled) &&\n    (isMovable(state, key) || isPremovable(state, key))\n  ) {\n    setSelected(state, key);\n    state.hold.start();\n  }\n}\n\nexport function setSelected(state: HeadlessState, key: cg.Key): void {\n  state.selected = key;\n  if (isPremovable(state, key)) {\n    // calculate chess premoves if custom premoves are not passed\n    if (!state.premovable.customDests) {\n      state.premovable.dests = premove(state.pieces, key, state.premovable.castle);\n    }\n  } else state.premovable.dests = undefined;\n}\n\nexport function unselect(state: HeadlessState): void {\n  state.selected = undefined;\n  state.premovable.dests = undefined;\n  state.hold.cancel();\n}\n\nfunction isMovable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && state.turnColor === piece.color))\n  );\n}\n\nexport const canMove = (state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean =>\n  orig !== dest &&\n  isMovable(state, orig) &&\n  (state.movable.free || !!state.movable.dests?.get(orig)?.includes(dest));\n\nfunction canDrop(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    (orig === dest || !state.pieces.has(dest)) &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && state.turnColor === piece.color))\n  );\n}\n\nfunction isPremovable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    state.premovable.enabled &&\n    state.movable.color === piece.color &&\n    state.turnColor !== piece.color\n  );\n}\n\nfunction canPremove(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const validPremoves: cg.Key[] =\n    state.premovable.customDests?.get(orig) ?? premove(state.pieces, orig, state.premovable.castle);\n  return orig !== dest && isPremovable(state, orig) && validPremoves.includes(dest);\n}\n\nfunction canPredrop(state: HeadlessState, orig: cg.Key, dest: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  const destPiece = state.pieces.get(dest);\n  return (\n    !!piece &&\n    (!destPiece || destPiece.color !== state.movable.color) &&\n    state.predroppable.enabled &&\n    (piece.role !== 'pawn' || (dest[1] !== '1' && dest[1] !== '8')) &&\n    state.movable.color === piece.color &&\n    state.turnColor !== piece.color\n  );\n}\n\nexport function isDraggable(state: HeadlessState, orig: cg.Key): boolean {\n  const piece = state.pieces.get(orig);\n  return (\n    !!piece &&\n    state.draggable.enabled &&\n    (state.movable.color === 'both' ||\n      (state.movable.color === piece.color && (state.turnColor === piece.color || state.premovable.enabled)))\n  );\n}\n\nexport function playPremove(state: HeadlessState): boolean {\n  const move = state.premovable.current;\n  if (!move) return false;\n  const orig = move[0],\n    dest = move[1];\n  let success = false;\n  if (canMove(state, orig, dest)) {\n    const result = baseUserMove(state, orig, dest);\n    if (result) {\n      const metadata: cg.MoveMetadata = { premove: true };\n      if (result !== true) metadata.captured = result;\n      callUserFunction(state.movable.events.after, orig, dest, metadata);\n      success = true;\n    }\n  }\n  unsetPremove(state);\n  return success;\n}\n\nexport function playPredrop(state: HeadlessState, validate: (drop: cg.Drop) => boolean): boolean {\n  const drop = state.predroppable.current;\n  let success = false;\n  if (!drop) return false;\n  if (validate(drop)) {\n    const piece = {\n      role: drop.role,\n      color: state.movable.color,\n    } as cg.Piece;\n    if (baseNewPiece(state, piece, drop.key)) {\n      callUserFunction(state.movable.events.afterNewPiece, drop.role, drop.key, {\n        premove: false,\n        predrop: true,\n      });\n      success = true;\n    }\n  }\n  unsetPredrop(state);\n  return success;\n}\n\nexport function cancelMove(state: HeadlessState): void {\n  unsetPremove(state);\n  unsetPredrop(state);\n  unselect(state);\n}\n\nexport function stop(state: HeadlessState): void {\n  state.movable.color = state.movable.dests = state.animation.current = undefined;\n  cancelMove(state);\n}\n\nexport function getKeyAtDomPos(\n  pos: cg.NumberPair,\n  asWhite: boolean,\n  bounds: DOMRectReadOnly,\n): cg.Key | undefined {\n  let file = Math.floor((8 * (pos[0] - bounds.left)) / bounds.width);\n  if (!asWhite) file = 7 - file;\n  let rank = 7 - Math.floor((8 * (pos[1] - bounds.top)) / bounds.height);\n  if (!asWhite) rank = 7 - rank;\n  return file >= 0 && file < 8 && rank >= 0 && rank < 8 ? pos2key([file, rank]) : undefined;\n}\n\nexport function getSnappedKeyAtDomPos(\n  orig: cg.Key,\n  pos: cg.NumberPair,\n  asWhite: boolean,\n  bounds: DOMRectReadOnly,\n): cg.Key | undefined {\n  const origPos = key2pos(orig);\n  const validSnapPos = allPos.filter(\n    pos2 =>\n      queen(origPos[0], origPos[1], pos2[0], pos2[1]) || knight(origPos[0], origPos[1], pos2[0], pos2[1]),\n  );\n  const validSnapCenters = validSnapPos.map(pos2 => computeSquareCenter(pos2key(pos2), asWhite, bounds));\n  const validSnapDistances = validSnapCenters.map(pos2 => distanceSq(pos, pos2));\n  const [, closestSnapIndex] = validSnapDistances.reduce(\n    (a, b, index) => (a[0] < b ? a : [b, index]),\n    [validSnapDistances[0], 0],\n  );\n  return pos2key(validSnapPos[closestSnapIndex]);\n}\n\nexport const whitePov = (s: HeadlessState): boolean => s.orientation === 'white';\n", "import { pos2key, invRanks } from './util.js';\nimport * as cg from './types.js';\n\nexport const initial: cg.FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\n\nconst roles: { [letter: string]: cg.Role } = {\n  p: 'pawn',\n  r: 'rook',\n  n: 'knight',\n  b: 'bishop',\n  q: 'queen',\n  k: 'king',\n};\n\nconst letters = {\n  pawn: 'p',\n  rook: 'r',\n  knight: 'n',\n  bishop: 'b',\n  queen: 'q',\n  king: 'k',\n};\n\nexport function read(fen: cg.FEN): cg.Pieces {\n  if (fen === 'start') fen = initial;\n  const pieces: cg.Pieces = new Map();\n  let row = 7,\n    col = 0;\n  for (const c of fen) {\n    switch (c) {\n      case ' ':\n      case '[':\n        return pieces;\n      case '/':\n        --row;\n        if (row < 0) return pieces;\n        col = 0;\n        break;\n      case '~': {\n        const piece = pieces.get(pos2key([col - 1, row]));\n        if (piece) piece.promoted = true;\n        break;\n      }\n      default: {\n        const nb = c.charCodeAt(0);\n        if (nb < 57) col += nb - 48;\n        else {\n          const role = c.toLowerCase();\n          pieces.set(pos2key([col, row]), {\n            role: roles[role],\n            color: c === role ? 'black' : 'white',\n          });\n          ++col;\n        }\n      }\n    }\n  }\n  return pieces;\n}\n\nexport function write(pieces: cg.Pieces): cg.FEN {\n  return invRanks\n    .map(y =>\n      cg.files\n        .map(x => {\n          const piece = pieces.get((x + y) as cg.Key);\n          if (piece) {\n            let p = letters[piece.role];\n            if (piece.color === 'white') p = p.toUpperCase();\n            if (piece.promoted) p += '~';\n            return p;\n          } else return '1';\n        })\n        .join(''),\n    )\n    .join('/')\n    .replace(/1{2,}/g, s => s.length.toString());\n}\n", "import { HeadlessState } from './state.js';\nimport { setCheck, setSelected } from './board.js';\nimport { read as fenRead } from './fen.js';\nimport { DrawShape, DrawBrushes } from './draw.js';\nimport * as cg from './types.js';\n\nexport interface Config {\n  fen?: cg.FEN; // chess position in Forsyth notation\n  orientation?: cg.Color; // board orientation. white | black\n  turnColor?: cg.Color; // turn to play. white | black\n  check?: cg.Color | boolean; // true for current color, false to unset\n  lastMove?: cg.Key[]; // squares part of the last move [\"c3\", \"c4\"]\n  selected?: cg.Key; // square currently selected \"a1\"\n  coordinates?: boolean; // include coords attributes\n  coordinatesOnSquares?: boolean; // include coords attributes on every square\n  autoCastle?: boolean; // immediately complete the castle by moving the rook after king move\n  viewOnly?: boolean; // don't bind events: the user will never be able to move pieces around\n  disableContextMenu?: boolean; // because who needs a context menu on a chessboard\n  addPieceZIndex?: boolean; // adds z-index values to pieces (for 3D)\n  addDimensionsCssVarsTo?: HTMLElement; // add ---cg-width and ---cg-height CSS vars containing the board's dimensions to this element\n  blockTouchScroll?: boolean; // block scrolling via touch dragging on the board, e.g. for coordinate training\n  // pieceKey: boolean; // add a data-key attribute to piece elements\n  trustAllEvents?: boolean; // disable checking for human only input (e.isTrusted)\n  highlight?: {\n    lastMove?: boolean; // add last-move class to squares\n    check?: boolean; // add check class to squares\n    custom?: cg.SquareClasses; // add custom classes to custom squares\n  };\n  animation?: {\n    enabled?: boolean;\n    duration?: number;\n  };\n  movable?: {\n    free?: boolean; // all moves are valid - board editor\n    color?: cg.Color | 'both'; // color that can move. white | black | both | undefined\n    dests?: cg.Dests; // valid moves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    showDests?: boolean; // whether to add the move-dest class on squares\n    events?: {\n      after?: (orig: cg.Key, dest: cg.Key, metadata: cg.MoveMetadata) => void; // called after the move has been played\n      afterNewPiece?: (role: cg.Role, key: cg.Key, metadata: cg.MoveMetadata) => void; // called after a new piece is dropped on the board\n    };\n    rookCastle?: boolean; // castle by moving the king to the rook\n  };\n  premovable?: {\n    enabled?: boolean; // allow premoves for color that can not move\n    showDests?: boolean; // whether to add the premove-dest class on squares\n    castle?: boolean; // whether to allow king castle premoves\n    dests?: cg.Key[]; // premove destinations for the current selection\n    customDests?: cg.Dests; // use custom valid premoves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    events?: {\n      set?: (orig: cg.Key, dest: cg.Key, metadata?: cg.SetPremoveMetadata) => void; // called after the premove has been set\n      unset?: () => void; // called after the premove has been unset\n    };\n  };\n  predroppable?: {\n    enabled?: boolean; // allow predrops for color that can not move\n    events?: {\n      set?: (role: cg.Role, key: cg.Key) => void; // called after the predrop has been set\n      unset?: () => void; // called after the predrop has been unset\n    };\n  };\n  draggable?: {\n    enabled?: boolean; // allow moves & premoves to use drag'n drop\n    distance?: number; // minimum distance to initiate a drag; in pixels\n    autoDistance?: boolean; // lets chessground set distance to zero when user drags pieces\n    showGhost?: boolean; // show ghost of piece being dragged\n    deleteOnDropOff?: boolean; // delete a piece when it is dropped off the board\n  };\n  selectable?: {\n    // disable to enforce dragging over click-click move\n    enabled?: boolean;\n  };\n  events?: {\n    change?: () => void; // called after the situation changes on the board\n    // called after a piece has been moved.\n    // capturedPiece is undefined or like {color: 'white'; 'role': 'queen'}\n    move?: (orig: cg.Key, dest: cg.Key, capturedPiece?: cg.Piece) => void;\n    dropNewPiece?: (piece: cg.Piece, key: cg.Key) => void;\n    select?: (key: cg.Key) => void; // called when a square is selected\n    insert?: (elements: cg.Elements) => void; // when the board DOM has been (re)inserted\n  };\n  drawable?: {\n    enabled?: boolean; // can draw\n    visible?: boolean; // can view\n    defaultSnapToValidMove?: boolean;\n    // false to keep the drawing if a movable piece is clicked.\n    // Clicking an empty square or immovable piece will clear the drawing regardless.\n    eraseOnClick?: boolean;\n    shapes?: DrawShape[];\n    autoShapes?: DrawShape[];\n    brushes?: DrawBrushes;\n    onChange?: (shapes: DrawShape[]) => void; // called after drawable shapes change\n  };\n}\n\nexport function applyAnimation(state: HeadlessState, config: Config): void {\n  if (config.animation) {\n    deepMerge(state.animation, config.animation);\n    // no need for such short animations\n    if ((state.animation.duration || 0) < 70) state.animation.enabled = false;\n  }\n}\n\nexport function configure(state: HeadlessState, config: Config): void {\n  // don't merge destinations and autoShapes. Just override.\n  if (config.movable?.dests) state.movable.dests = undefined;\n  if (config.drawable?.autoShapes) state.drawable.autoShapes = [];\n\n  deepMerge(state, config);\n\n  // if a fen was provided, replace the pieces\n  if (config.fen) {\n    state.pieces = fenRead(config.fen);\n    state.drawable.shapes = config.drawable?.shapes || [];\n  }\n\n  // apply config values that could be undefined yet meaningful\n  if ('check' in config) setCheck(state, config.check || false);\n  if ('lastMove' in config && !config.lastMove) state.lastMove = undefined;\n  // in case of ZH drop last move, there's a single square.\n  // if the previous last move had two squares,\n  // the merge algorithm will incorrectly keep the second square.\n  else if (config.lastMove) state.lastMove = config.lastMove;\n\n  // fix move/premove dests\n  if (state.selected) setSelected(state, state.selected);\n\n  applyAnimation(state, config);\n\n  if (!state.movable.rookCastle && state.movable.dests) {\n    const rank = state.movable.color === 'white' ? '1' : '8',\n      kingStartPos = ('e' + rank) as cg.Key,\n      dests = state.movable.dests.get(kingStartPos),\n      king = state.pieces.get(kingStartPos);\n    if (!dests || !king || king.role !== 'king') return;\n    state.movable.dests.set(\n      kingStartPos,\n      dests.filter(\n        d =>\n          !(d === 'a' + rank && dests.includes(('c' + rank) as cg.Key)) &&\n          !(d === 'h' + rank && dests.includes(('g' + rank) as cg.Key)),\n      ),\n    );\n  }\n}\n\nfunction deepMerge(base: any, extend: any): void {\n  for (const key in extend) {\n    if (key === '__proto__' || key === 'constructor' || !Object.prototype.hasOwnProperty.call(extend, key))\n      continue;\n    if (\n      Object.prototype.hasOwnProperty.call(base, key) &&\n      isPlainObject(base[key]) &&\n      isPlainObject(extend[key])\n    )\n      deepMerge(base[key], extend[key]);\n    else base[key] = extend[key];\n  }\n}\n\nfunction isPlainObject(o: unknown): boolean {\n  if (typeof o !== 'object' || o === null) return false;\n  const proto = Object.getPrototypeOf(o);\n  return proto === Object.prototype || proto === null;\n}\n", "import { State } from './state.js';\nimport * as util from './util.js';\nimport * as cg from './types.js';\n\nexport type Mutation<A> = (state: State) => A;\n\n// 0,1 animation goal\n// 2,3 animation current status\nexport type AnimVector = cg.NumberQuad;\n\nexport type AnimVectors = Map<cg.Key, AnimVector>;\n\nexport type AnimFadings = Map<cg.Key, cg.Piece>;\n\nexport interface AnimPlan {\n  anims: AnimVectors;\n  fadings: AnimFadings;\n}\n\nexport interface AnimCurrent {\n  start: DOMHighResTimeStamp;\n  frequency: cg.KHz;\n  plan: AnimPlan;\n}\n\nexport const anim = <A>(mutation: Mutation<A>, state: State): A =>\n  state.animation.enabled ? animate(mutation, state) : render(mutation, state);\n\nexport function render<A>(mutation: Mutation<A>, state: State): A {\n  const result = mutation(state);\n  state.dom.redraw();\n  return result;\n}\n\ninterface AnimPiece {\n  key: cg.Key;\n  pos: cg.Pos;\n  piece: cg.Piece;\n}\ntype AnimPieces = Map<cg.Key, AnimPiece>;\n\nconst makePiece = (key: cg.Key, piece: cg.Piece): AnimPiece => ({\n  key: key,\n  pos: util.key2pos(key),\n  piece: piece,\n});\n\nconst closer = (piece: AnimPiece, pieces: AnimPiece[]): AnimPiece | undefined =>\n  pieces.sort((p1, p2) => util.distanceSq(piece.pos, p1.pos) - util.distanceSq(piece.pos, p2.pos))[0];\n\nfunction computePlan(prevPieces: cg.Pieces, current: State): AnimPlan {\n  const anims: AnimVectors = new Map(),\n    animedOrigs: cg.Key[] = [],\n    fadings: AnimFadings = new Map(),\n    missings: AnimPiece[] = [],\n    news: AnimPiece[] = [],\n    prePieces: AnimPieces = new Map();\n  let curP: cg.Piece | undefined, preP: AnimPiece | undefined, vector: cg.NumberPair;\n  for (const [k, p] of prevPieces) {\n    prePieces.set(k, makePiece(k, p));\n  }\n  for (const key of util.allKeys) {\n    curP = current.pieces.get(key);\n    preP = prePieces.get(key);\n    if (curP) {\n      if (preP) {\n        if (!util.samePiece(curP, preP.piece)) {\n          missings.push(preP);\n          news.push(makePiece(key, curP));\n        }\n      } else news.push(makePiece(key, curP));\n    } else if (preP) missings.push(preP);\n  }\n  for (const newP of news) {\n    preP = closer(\n      newP,\n      missings.filter(p => util.samePiece(newP.piece, p.piece)),\n    );\n    if (preP) {\n      vector = [preP.pos[0] - newP.pos[0], preP.pos[1] - newP.pos[1]];\n      anims.set(newP.key, vector.concat(vector) as AnimVector);\n      animedOrigs.push(preP.key);\n    }\n  }\n  for (const p of missings) {\n    if (!animedOrigs.includes(p.key)) fadings.set(p.key, p.piece);\n  }\n\n  return {\n    anims: anims,\n    fadings: fadings,\n  };\n}\n\nfunction step(state: State, now: DOMHighResTimeStamp): void {\n  const cur = state.animation.current;\n  if (cur === undefined) {\n    // animation was canceled :(\n    if (!state.dom.destroyed) state.dom.redrawNow();\n    return;\n  }\n  const rest = 1 - (now - cur.start) * cur.frequency;\n  if (rest <= 0) {\n    state.animation.current = undefined;\n    state.dom.redrawNow();\n  } else {\n    const ease = easing(rest);\n    for (const cfg of cur.plan.anims.values()) {\n      cfg[2] = cfg[0] * ease;\n      cfg[3] = cfg[1] * ease;\n    }\n    state.dom.redrawNow(true); // optimisation: don't render SVG changes during animations\n    requestAnimationFrame((now = performance.now()) => step(state, now));\n  }\n}\n\nfunction animate<A>(mutation: Mutation<A>, state: State): A {\n  // clone state before mutating it\n  const prevPieces: cg.Pieces = new Map(state.pieces);\n\n  const result = mutation(state);\n  const plan = computePlan(prevPieces, state);\n  if (plan.anims.size || plan.fadings.size) {\n    const alreadyRunning = state.animation.current && state.animation.current.start;\n    state.animation.current = {\n      start: performance.now(),\n      frequency: 1 / state.animation.duration,\n      plan: plan,\n    };\n    if (!alreadyRunning) step(state, performance.now());\n  } else {\n    // don't animate, just render right away\n    state.dom.redraw();\n  }\n  return result;\n}\n\n// https://gist.github.com/gre/1650294\nconst easing = (t: number): number => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1);\n", "import { State } from './state.js';\nimport { unselect, cancelMove, getKeyAtDomPos, getSnappedKeyAtDomPos, whitePov } from './board.js';\nimport { eventPosition, isRightButton } from './util.js';\nimport * as cg from './types.js';\n\nexport interface DrawShape {\n  orig: cg.Key;\n  dest?: cg.Key;\n  brush?: string; // if no brush, no shape. label moved to top right of square\n  modifiers?: DrawModifiers;\n  piece?: DrawShapePiece;\n  customSvg?: { html: string; center?: 'orig' | 'dest' | 'label' }; // 100 x 100 viewbox cenetered at [50,50]\n  label?: { text: string; fill?: string }; // fill is in '#rrggbb' format\n}\n\nexport interface DrawModifiers {\n  lineWidth?: number;\n  hilite?: boolean;\n}\n\nexport interface DrawShapePiece {\n  role: cg.Role;\n  color: cg.Color;\n  scale?: number;\n}\n\nexport interface DrawBrush {\n  key: string;\n  color: string;\n  opacity: number;\n  lineWidth: number;\n}\n\nexport interface DrawBrushes {\n  green: DrawBrush;\n  red: DrawBrush;\n  blue: DrawBrush;\n  yellow: DrawBrush;\n  [color: string]: DrawBrush;\n}\n\nexport interface Drawable {\n  enabled: boolean; // can draw\n  visible: boolean; // can view\n  defaultSnapToValidMove: boolean;\n  eraseOnClick: boolean;\n  onChange?: (shapes: DrawShape[]) => void;\n  shapes: DrawShape[]; // user shapes\n  autoShapes: DrawShape[]; // computer shapes\n  current?: DrawCurrent;\n  brushes: DrawBrushes;\n  prevSvgHash: string;\n}\n\nexport interface DrawCurrent {\n  orig: cg.Key; // orig key of drawing\n  dest?: cg.Key; // shape dest, or undefined for circle\n  mouseSq?: cg.Key; // square being moused over\n  pos: cg.NumberPair; // relative current position\n  brush: cg.BrushColor; // brush name for shape\n  snapToValidMove: boolean; // whether to snap to valid piece moves\n}\n\nconst brushes: cg.BrushColor[] = ['green', 'red', 'blue', 'yellow'];\n\nexport function start(state: State, e: cg.MouchEvent): void {\n  // support one finger touch only\n  if (e.touches && e.touches.length > 1) return;\n  e.stopPropagation();\n  e.preventDefault();\n  e.ctrlKey ? unselect(state) : cancelMove(state);\n  const pos = eventPosition(e)!,\n    orig = getKeyAtDomPos(pos, whitePov(state), state.dom.bounds());\n  if (!orig) return;\n  state.drawable.current = {\n    orig,\n    pos,\n    brush: eventBrush(e),\n    snapToValidMove: state.drawable.defaultSnapToValidMove,\n  };\n\n  processDraw(state);\n}\n\nexport function processDraw(state: State): void {\n  requestAnimationFrame(() => {\n    const cur = state.drawable.current;\n    if (cur) {\n      const keyAtDomPos = getKeyAtDomPos(cur.pos, whitePov(state), state.dom.bounds());\n      if (!keyAtDomPos) {\n        cur.snapToValidMove = false;\n      }\n      const mouseSq = cur.snapToValidMove\n        ? getSnappedKeyAtDomPos(cur.orig, cur.pos, whitePov(state), state.dom.bounds())\n        : keyAtDomPos;\n      if (mouseSq !== cur.mouseSq) {\n        cur.mouseSq = mouseSq;\n        cur.dest = mouseSq !== cur.orig ? mouseSq : undefined;\n        state.dom.redrawNow();\n      }\n      processDraw(state);\n    }\n  });\n}\n\nexport function move(state: State, e: cg.MouchEvent): void {\n  if (state.drawable.current) state.drawable.current.pos = eventPosition(e)!;\n}\n\nexport function end(state: State): void {\n  const cur = state.drawable.current;\n  if (cur) {\n    if (cur.mouseSq) addShape(state.drawable, cur);\n    cancel(state);\n  }\n}\n\nexport function cancel(state: State): void {\n  if (state.drawable.current) {\n    state.drawable.current = undefined;\n    state.dom.redraw();\n  }\n}\n\nexport function clear(state: State): void {\n  if (state.drawable.shapes.length) {\n    state.drawable.shapes = [];\n    state.dom.redraw();\n    onChange(state.drawable);\n  }\n}\n\nfunction eventBrush(e: cg.MouchEvent): cg.BrushColor {\n  const modA = (e.shiftKey || e.ctrlKey) && isRightButton(e);\n  const modB = e.altKey || e.metaKey || e.getModifierState?.('AltGraph');\n  return brushes[(modA ? 1 : 0) + (modB ? 2 : 0)];\n}\n\nfunction addShape(drawable: Drawable, cur: DrawCurrent): void {\n  const sameShape = (s: DrawShape) => s.orig === cur.orig && s.dest === cur.dest;\n  const similar = drawable.shapes.find(sameShape);\n  if (similar) drawable.shapes = drawable.shapes.filter(s => !sameShape(s));\n  if (!similar || similar.brush !== cur.brush)\n    drawable.shapes.push({\n      orig: cur.orig,\n      dest: cur.dest,\n      brush: cur.brush,\n    });\n  onChange(drawable);\n}\n\nfunction onChange(drawable: Drawable): void {\n  if (drawable.onChange) drawable.onChange(drawable.shapes);\n}\n", "import { State } from './state.js';\nimport * as board from './board.js';\nimport * as util from './util.js';\nimport { clear as drawClear } from './draw.js';\nimport * as cg from './types.js';\nimport { anim } from './anim.js';\n\nexport interface DragCurrent {\n  orig: cg.Key; // orig key of dragging piece\n  piece: cg.Piece;\n  origPos: cg.NumberPair; // first event position\n  pos: cg.NumberPair; // latest event position\n  started: boolean; // whether the drag has started; as per the distance setting\n  element: cg.PieceNode | (() => cg.PieceNode | undefined);\n  newPiece?: boolean; // it it a new piece from outside the board\n  force?: boolean; // can the new piece replace an existing one (editor)\n  previouslySelected?: cg.Key;\n  originTarget: EventTarget | null;\n  keyHasChanged: boolean; // whether the drag has left the orig key\n}\n\nexport function start(s: State, e: cg.MouchEvent): void {\n  if (!(s.trustAllEvents || e.isTrusted)) return; // only trust when trustAllEvents is enabled\n  if (e.buttons !== undefined && e.buttons > 1) return; // only touch or left click\n  if (e.touches && e.touches.length > 1) return; // support one finger touch only\n  const bounds = s.dom.bounds(),\n    position = util.eventPosition(e)!,\n    orig = board.getKeyAtDomPos(position, board.whitePov(s), bounds);\n  if (!orig) return;\n  const piece = s.pieces.get(orig);\n  const previouslySelected = s.selected;\n  if (\n    !previouslySelected &&\n    s.drawable.enabled &&\n    (s.drawable.eraseOnClick || !piece || piece.color !== s.turnColor)\n  )\n    drawClear(s);\n  // Prevent touch scroll and create no corresponding mouse event, if there\n  // is an intent to interact with the board.\n  if (\n    e.cancelable !== false &&\n    (!e.touches || s.blockTouchScroll || piece || previouslySelected || pieceCloseTo(s, position))\n  )\n    e.preventDefault();\n  else if (e.touches) return; // Handle only corresponding mouse event https://github.com/lichess-org/chessground/pull/268\n\n  const hadPremove = !!s.premovable.current;\n  const hadPredrop = !!s.predroppable.current;\n  s.stats.ctrlKey = e.ctrlKey;\n  if (s.selected && board.canMove(s, s.selected, orig)) {\n    anim(state => board.selectSquare(state, orig), s);\n  } else {\n    board.selectSquare(s, orig);\n  }\n  const stillSelected = s.selected === orig;\n  const element = pieceElementByKey(s, orig);\n  if (piece && element && stillSelected && board.isDraggable(s, orig)) {\n    s.draggable.current = {\n      orig,\n      piece,\n      origPos: position,\n      pos: position,\n      started: s.draggable.autoDistance && s.stats.dragged,\n      element,\n      previouslySelected,\n      originTarget: e.target,\n      keyHasChanged: false,\n    };\n    element.cgDragging = true;\n    element.classList.add('dragging');\n    // place ghost\n    const ghost = s.dom.elements.ghost;\n    if (ghost) {\n      ghost.className = `ghost ${piece.color} ${piece.role}`;\n      util.translate(ghost, util.posToTranslate(bounds)(util.key2pos(orig), board.whitePov(s)));\n      util.setVisible(ghost, true);\n    }\n    processDrag(s);\n  } else {\n    if (hadPremove) board.unsetPremove(s);\n    if (hadPredrop) board.unsetPredrop(s);\n  }\n  s.dom.redraw();\n}\n\nfunction pieceCloseTo(s: State, pos: cg.NumberPair): boolean {\n  const asWhite = board.whitePov(s),\n    bounds = s.dom.bounds(),\n    radiusSq = Math.pow(bounds.width / 8, 2);\n  for (const key of s.pieces.keys()) {\n    const center = util.computeSquareCenter(key, asWhite, bounds);\n    if (util.distanceSq(center, pos) <= radiusSq) return true;\n  }\n  return false;\n}\n\nexport function dragNewPiece(s: State, piece: cg.Piece, e: cg.MouchEvent, force?: boolean): void {\n  const key: cg.Key = 'a0';\n  s.pieces.set(key, piece);\n  s.dom.redraw();\n\n  const position = util.eventPosition(e)!;\n\n  s.draggable.current = {\n    orig: key,\n    piece,\n    origPos: position,\n    pos: position,\n    started: true,\n    element: () => pieceElementByKey(s, key),\n    originTarget: e.target,\n    newPiece: true,\n    force: !!force,\n    keyHasChanged: false,\n  };\n  processDrag(s);\n}\n\nfunction processDrag(s: State): void {\n  requestAnimationFrame(() => {\n    const cur = s.draggable.current;\n    if (!cur) return;\n    // cancel animations while dragging\n    if (s.animation.current?.plan.anims.has(cur.orig)) s.animation.current = undefined;\n    // if moving piece is gone, cancel\n    const origPiece = s.pieces.get(cur.orig);\n    if (!origPiece || !util.samePiece(origPiece, cur.piece)) cancel(s);\n    else {\n      if (!cur.started && util.distanceSq(cur.pos, cur.origPos) >= Math.pow(s.draggable.distance, 2))\n        cur.started = true;\n      if (cur.started) {\n        // support lazy elements\n        if (typeof cur.element === 'function') {\n          const found = cur.element();\n          if (!found) return;\n          found.cgDragging = true;\n          found.classList.add('dragging');\n          cur.element = found;\n        }\n\n        const bounds = s.dom.bounds();\n        util.translate(cur.element, [\n          cur.pos[0] - bounds.left - bounds.width / 16,\n          cur.pos[1] - bounds.top - bounds.height / 16,\n        ]);\n\n        cur.keyHasChanged ||= cur.orig !== board.getKeyAtDomPos(cur.pos, board.whitePov(s), bounds);\n      }\n    }\n    processDrag(s);\n  });\n}\n\nexport function move(s: State, e: cg.MouchEvent): void {\n  // support one finger touch only\n  if (s.draggable.current && (!e.touches || e.touches.length < 2)) {\n    s.draggable.current.pos = util.eventPosition(e)!;\n  }\n}\n\nexport function end(s: State, e: cg.MouchEvent): void {\n  const cur = s.draggable.current;\n  if (!cur) return;\n  // create no corresponding mouse event\n  if (e.type === 'touchend' && e.cancelable !== false) e.preventDefault();\n  // comparing with the origin target is an easy way to test that the end event\n  // has the same touch origin\n  if (e.type === 'touchend' && cur.originTarget !== e.target && !cur.newPiece) {\n    s.draggable.current = undefined;\n    return;\n  }\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n  // touchend has no position; so use the last touchmove position instead\n  const eventPos = util.eventPosition(e) || cur.pos;\n  const dest = board.getKeyAtDomPos(eventPos, board.whitePov(s), s.dom.bounds());\n  if (dest && cur.started && cur.orig !== dest) {\n    if (cur.newPiece) board.dropNewPiece(s, cur.orig, dest, cur.force);\n    else {\n      s.stats.ctrlKey = e.ctrlKey;\n      if (board.userMove(s, cur.orig, dest)) s.stats.dragged = true;\n    }\n  } else if (cur.newPiece) {\n    s.pieces.delete(cur.orig);\n  } else if (s.draggable.deleteOnDropOff && !dest) {\n    s.pieces.delete(cur.orig);\n    board.callUserFunction(s.events.change);\n  }\n  if ((cur.orig === cur.previouslySelected || cur.keyHasChanged) && (cur.orig === dest || !dest))\n    board.unselect(s);\n  else if (!s.selectable.enabled) board.unselect(s);\n\n  removeDragElements(s);\n\n  s.draggable.current = undefined;\n  s.dom.redraw();\n}\n\nexport function cancel(s: State): void {\n  const cur = s.draggable.current;\n  if (cur) {\n    if (cur.newPiece) s.pieces.delete(cur.orig);\n    s.draggable.current = undefined;\n    board.unselect(s);\n    removeDragElements(s);\n    s.dom.redraw();\n  }\n}\n\nfunction removeDragElements(s: State): void {\n  const e = s.dom.elements;\n  if (e.ghost) util.setVisible(e.ghost, false);\n}\n\nfunction pieceElementByKey(s: State, key: cg.Key): cg.PieceNode | undefined {\n  let el = s.dom.elements.board.firstChild;\n  while (el) {\n    if ((el as cg.KeyedNode).cgKey === key && (el as cg.KeyedNode).tagName === 'PIECE')\n      return el as cg.PieceNode;\n    el = el.nextSibling;\n  }\n  return;\n}\n", "import { State } from './state.js';\nimport { Key } from './types.js';\n\nexport function explosion(state: State, keys: Key[]): void {\n  state.exploding = { stage: 1, keys };\n  state.dom.redraw();\n  setTimeout(() => {\n    setStage(state, 2);\n    setTimeout(() => setStage(state, undefined), 120);\n  }, 120);\n}\n\nfunction setStage(state: State, stage: number | undefined): void {\n  if (state.exploding) {\n    if (stage) state.exploding.stage = stage;\n    else state.exploding = undefined;\n    state.dom.redraw();\n  }\n}\n", "import { State } from './state.js';\nimport * as board from './board.js';\nimport { write as fenWrite } from './fen.js';\nimport { Config, configure, applyAnimation } from './config.js';\nimport { anim, render } from './anim.js';\nimport { cancel as dragCancel, dragNewPiece } from './drag.js';\nimport { DrawShape } from './draw.js';\nimport { explosion } from './explosion.js';\nimport * as cg from './types.js';\n\nexport interface Api {\n  // reconfigure the instance. Accepts all config options, except for viewOnly & drawable.visible.\n  // board will be animated accordingly, if animations are enabled.\n  set(config: Config): void;\n\n  // read chessground state; write at your own risks.\n  state: State;\n\n  // get the position as a FEN string (only contains pieces, no flags)\n  // e.g. rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR\n  getFen(): cg.FEN;\n\n  // change the view angle\n  toggleOrientation(): void;\n\n  // perform a move programmatically\n  move(orig: cg.Key, dest: cg.Key): void;\n\n  // add and/or remove arbitrary pieces on the board\n  setPieces(pieces: cg.PiecesDiff): void;\n\n  // click a square programmatically\n  selectSquare(key: cg.Key | null, force?: boolean): void;\n\n  // put a new piece on the board\n  newPiece(piece: cg.Piece, key: cg.Key): void;\n\n  // play the current premove, if any; returns true if premove was played\n  playPremove(): boolean;\n\n  // cancel the current premove, if any\n  cancelPremove(): void;\n\n  // play the current predrop, if any; returns true if premove was played\n  playPredrop(validate: (drop: cg.Drop) => boolean): boolean;\n\n  // cancel the current predrop, if any\n  cancelPredrop(): void;\n\n  // cancel the current move being made\n  cancelMove(): void;\n\n  // cancel current move and prevent further ones\n  stop(): void;\n\n  // make squares explode (atomic chess)\n  explode(keys: cg.Key[]): void;\n\n  // programmatically draw user shapes\n  setShapes(shapes: DrawShape[]): void;\n\n  // programmatically draw auto shapes\n  setAutoShapes(shapes: DrawShape[]): void;\n\n  // square name at this DOM position (like \"e4\")\n  getKeyAtDomPos(pos: cg.NumberPair): cg.Key | undefined;\n\n  // only useful when CSS changes the board width/height ratio (for 3D)\n  redrawAll: cg.Redraw;\n\n  // for crazyhouse and board editors\n  dragNewPiece(piece: cg.Piece, event: cg.MouchEvent, force?: boolean): void;\n\n  // unbinds all events\n  // (important for document-wide events like scroll and mousemove)\n  destroy: cg.Unbind;\n}\n\n// see API types and documentations in dts/api.d.ts\nexport function start(state: State, redrawAll: cg.Redraw): Api {\n  function toggleOrientation(): void {\n    board.toggleOrientation(state);\n    redrawAll();\n  }\n\n  return {\n    set(config): void {\n      if (config.orientation && config.orientation !== state.orientation) toggleOrientation();\n      applyAnimation(state, config);\n      (config.fen ? anim : render)(state => configure(state, config), state);\n    },\n\n    state,\n\n    getFen: () => fenWrite(state.pieces),\n\n    toggleOrientation,\n\n    setPieces(pieces): void {\n      anim(state => board.setPieces(state, pieces), state);\n    },\n\n    selectSquare(key, force): void {\n      if (key) anim(state => board.selectSquare(state, key, force), state);\n      else if (state.selected) {\n        board.unselect(state);\n        state.dom.redraw();\n      }\n    },\n\n    move(orig, dest): void {\n      anim(state => board.baseMove(state, orig, dest), state);\n    },\n\n    newPiece(piece, key): void {\n      anim(state => board.baseNewPiece(state, piece, key), state);\n    },\n\n    playPremove(): boolean {\n      if (state.premovable.current) {\n        if (anim(board.playPremove, state)) return true;\n        // if the premove couldn't be played, redraw to clear it up\n        state.dom.redraw();\n      }\n      return false;\n    },\n\n    playPredrop(validate): boolean {\n      if (state.predroppable.current) {\n        const result = board.playPredrop(state, validate);\n        state.dom.redraw();\n        return result;\n      }\n      return false;\n    },\n\n    cancelPremove(): void {\n      render(board.unsetPremove, state);\n    },\n\n    cancelPredrop(): void {\n      render(board.unsetPredrop, state);\n    },\n\n    cancelMove(): void {\n      render(state => {\n        board.cancelMove(state);\n        dragCancel(state);\n      }, state);\n    },\n\n    stop(): void {\n      render(state => {\n        board.stop(state);\n        dragCancel(state);\n      }, state);\n    },\n\n    explode(keys: cg.Key[]): void {\n      explosion(state, keys);\n    },\n\n    setAutoShapes(shapes: DrawShape[]): void {\n      render(state => (state.drawable.autoShapes = shapes), state);\n    },\n\n    setShapes(shapes: DrawShape[]): void {\n      render(state => (state.drawable.shapes = shapes), state);\n    },\n\n    getKeyAtDomPos(pos): cg.Key | undefined {\n      return board.getKeyAtDomPos(pos, board.whitePov(state), state.dom.bounds());\n    },\n\n    redrawAll,\n\n    dragNewPiece(piece, event, force): void {\n      dragNewPiece(state, piece, event, force);\n    },\n\n    destroy(): void {\n      board.stop(state);\n      state.dom.unbind && state.dom.unbind();\n      state.dom.destroyed = true;\n    },\n  };\n}\n", "import * as fen from './fen.js';\nimport { AnimCurrent } from './anim.js';\nimport { DragCurrent } from './drag.js';\nimport { Drawable } from './draw.js';\nimport { timer } from './util.js';\nimport * as cg from './types.js';\n\nexport interface HeadlessState {\n  pieces: cg.Pieces;\n  orientation: cg.Color; // board orientation. white | black\n  turnColor: cg.Color; // turn to play. white | black\n  check?: cg.Key; // square currently in check \"a2\"\n  lastMove?: cg.Key[]; // squares part of the last move [\"c3\"; \"c4\"]\n  selected?: cg.Key; // square currently selected \"a1\"\n  coordinates: boolean; // include coords attributes\n  coordinatesOnSquares: boolean; // include coords attributes on every square\n  ranksPosition: cg.RanksPosition; // position ranks on either side. left | right\n  autoCastle: boolean; // immediately complete the castle by moving the rook after king move\n  viewOnly: boolean; // don't bind events: the user will never be able to move pieces around\n  disableContextMenu: boolean; // because who needs a context menu on a chessboard\n  addPieceZIndex: boolean; // adds z-index values to pieces (for 3D)\n  addDimensionsCssVarsTo?: HTMLElement; // add ---cg-width and ---cg-height CSS vars containing the board's dimensions to this element\n  blockTouchScroll: boolean; // block scrolling via touch dragging on the board, e.g. for coordinate training\n  pieceKey: boolean; // add a data-key attribute to piece elements\n  trustAllEvents?: boolean; // disable checking for human only input (e.isTrusted)\n  highlight: {\n    lastMove: boolean; // add last-move class to squares\n    check: boolean; // add check class to squares\n    custom?: cg.SquareClasses; // add custom classes to custom squares\n  };\n  animation: {\n    enabled: boolean;\n    duration: number;\n    current?: AnimCurrent;\n  };\n  movable: {\n    free: boolean; // all moves are valid - board editor\n    color?: cg.Color | 'both'; // color that can move. white | black | both\n    dests?: cg.Dests; // valid moves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    showDests: boolean; // whether to add the move-dest class on squares\n    events: {\n      after?: (orig: cg.Key, dest: cg.Key, metadata: cg.MoveMetadata) => void; // called after the move has been played\n      afterNewPiece?: (role: cg.Role, key: cg.Key, metadata: cg.MoveMetadata) => void; // called after a new piece is dropped on the board\n    };\n    rookCastle: boolean; // castle by moving the king to the rook\n  };\n  premovable: {\n    enabled: boolean; // allow premoves for color that can not move\n    showDests: boolean; // whether to add the premove-dest class on squares\n    castle: boolean; // whether to allow king castle premoves\n    dests?: cg.Key[]; // premove destinations for the current selection\n    customDests?: cg.Dests; // use custom valid premoves. {\"a2\" [\"a3\" \"a4\"] \"b1\" [\"a3\" \"c3\"]}\n    current?: cg.KeyPair; // keys of the current saved premove [\"e2\" \"e4\"]\n    events: {\n      set?: (orig: cg.Key, dest: cg.Key, metadata?: cg.SetPremoveMetadata) => void; // called after the premove has been set\n      unset?: () => void; // called after the premove has been unset\n    };\n  };\n  predroppable: {\n    enabled: boolean; // allow predrops for color that can not move\n    current?: {\n      // current saved predrop {role: 'knight'; key: 'e4'}\n      role: cg.Role;\n      key: cg.Key;\n    };\n    events: {\n      set?: (role: cg.Role, key: cg.Key) => void; // called after the predrop has been set\n      unset?: () => void; // called after the predrop has been unset\n    };\n  };\n  draggable: {\n    enabled: boolean; // allow moves & premoves to use drag'n drop\n    distance: number; // minimum distance to initiate a drag; in pixels\n    autoDistance: boolean; // lets chessground set distance to zero when user drags pieces\n    showGhost: boolean; // show ghost of piece being dragged\n    deleteOnDropOff: boolean; // delete a piece when it is dropped off the board\n    current?: DragCurrent;\n  };\n  dropmode: {\n    active: boolean;\n    piece?: cg.Piece;\n  };\n  selectable: {\n    // disable to enforce dragging over click-click move\n    enabled: boolean;\n  };\n  stats: {\n    // was last piece dragged or clicked?\n    // needs default to false for touch\n    dragged: boolean;\n    ctrlKey?: boolean;\n  };\n  events: {\n    change?: () => void; // called after the situation changes on the board\n    // called after a piece has been moved.\n    // capturedPiece is undefined or like {color: 'white'; 'role': 'queen'}\n    move?: (orig: cg.Key, dest: cg.Key, capturedPiece?: cg.Piece) => void;\n    dropNewPiece?: (piece: cg.Piece, key: cg.Key) => void;\n    select?: (key: cg.Key) => void; // called when a square is selected\n    insert?: (elements: cg.Elements) => void; // when the board DOM has been (re)inserted\n  };\n  drawable: Drawable;\n  exploding?: cg.Exploding;\n  hold: cg.Timer;\n}\n\nexport interface State extends HeadlessState {\n  dom: cg.Dom;\n}\n\nexport function defaults(): HeadlessState {\n  return {\n    pieces: fen.read(fen.initial),\n    orientation: 'white',\n    turnColor: 'white',\n    coordinates: true,\n    coordinatesOnSquares: false,\n    ranksPosition: 'right',\n    autoCastle: true,\n    viewOnly: false,\n    disableContextMenu: false,\n    addPieceZIndex: false,\n    blockTouchScroll: false,\n    pieceKey: false,\n    trustAllEvents: false,\n    highlight: {\n      lastMove: true,\n      check: true,\n    },\n    animation: {\n      enabled: true,\n      duration: 200,\n    },\n    movable: {\n      free: true,\n      color: 'both',\n      showDests: true,\n      events: {},\n      rookCastle: true,\n    },\n    premovable: {\n      enabled: true,\n      showDests: true,\n      castle: true,\n      events: {},\n    },\n    predroppable: {\n      enabled: false,\n      events: {},\n    },\n    draggable: {\n      enabled: true,\n      distance: 3,\n      autoDistance: true,\n      showGhost: true,\n      deleteOnDropOff: false,\n    },\n    dropmode: {\n      active: false,\n    },\n    selectable: {\n      enabled: true,\n    },\n    stats: {\n      // on touchscreen, default to \"tap-tap\" moves\n      // instead of drag\n      dragged: !('ontouchstart' in window),\n    },\n    events: {},\n    drawable: {\n      enabled: true, // can draw\n      visible: true, // can view\n      defaultSnapToValidMove: true,\n      eraseOnClick: true,\n      shapes: [],\n      autoShapes: [],\n      brushes: {\n        green: { key: 'g', color: '#15781B', opacity: 1, lineWidth: 10 },\n        red: { key: 'r', color: '#882020', opacity: 1, lineWidth: 10 },\n        blue: { key: 'b', color: '#003088', opacity: 1, lineWidth: 10 },\n        yellow: { key: 'y', color: '#e68f00', opacity: 1, lineWidth: 10 },\n        paleBlue: { key: 'pb', color: '#003088', opacity: 0.4, lineWidth: 15 },\n        paleGreen: { key: 'pg', color: '#15781B', opacity: 0.4, lineWidth: 15 },\n        paleRed: { key: 'pr', color: '#882020', opacity: 0.4, lineWidth: 15 },\n        paleGrey: {\n          key: 'pgr',\n          color: '#4a4a4a',\n          opacity: 0.35,\n          lineWidth: 15,\n        },\n        purple: { key: 'purple', color: '#68217a', opacity: 0.65, lineWidth: 10 },\n        pink: { key: 'pink', color: '#ee2080', opacity: 0.5, lineWidth: 10 },\n        white: { key: 'white', color: 'white', opacity: 1, lineWidth: 10 },\n      },\n      prevSvgHash: '',\n    },\n    hold: timer(),\n  };\n}\n", "import { State } from './state.js';\nimport { key2pos } from './util.js';\nimport { Drawable, DrawShape, DrawShapePiece, DrawBrush, DrawBrushes, DrawModifiers } from './draw.js';\nimport { SyncableShape, Hash } from './sync.js';\nimport * as cg from './types.js';\n\ntype CustomBrushes = Map<string, DrawBrush>; // by hash\ntype Svg = { el: SVGElement; isCustom?: boolean };\ntype AngleSlots = Set<number>; // arrow angle slots for label positioning\ntype ArrowDests = Map<cg.Key | undefined, AngleSlots>; // angle slots per dest\n\nconst hilites: { [name: string]: DrawBrush } = {\n  hilitePrimary: { key: 'hilitePrimary', color: '#3291ff', opacity: 1, lineWidth: 1 },\n  hiliteWhite: { key: 'hiliteWhite', color: '#ffffff', opacity: 1, lineWidth: 1 },\n};\n\nexport { createElement, setAttributes };\n\nexport function createDefs(): Element {\n  const defs = createElement('defs');\n  const filter = setAttributes(createElement('filter'), { id: 'cg-filter-blur' });\n  filter.appendChild(setAttributes(createElement('feGaussianBlur'), { stdDeviation: '0.019' }));\n  defs.appendChild(filter);\n  return defs;\n}\n\nexport function renderSvg(state: State, shapesEl: SVGElement, customsEl: SVGElement): void {\n  const d = state.drawable,\n    curD = d.current,\n    cur = curD && curD.mouseSq ? (curD as DrawShape) : undefined,\n    dests: ArrowDests = new Map(),\n    bounds = state.dom.bounds(),\n    nonPieceAutoShapes = d.autoShapes.filter(autoShape => !autoShape.piece);\n\n  for (const s of d.shapes.concat(nonPieceAutoShapes).concat(cur ? [cur] : [])) {\n    if (!s.dest) continue;\n    const sources = dests.get(s.dest) ?? new Set(),\n      from = pos2user(orient(key2pos(s.orig), state.orientation), bounds),\n      to = pos2user(orient(key2pos(s.dest), state.orientation), bounds);\n    sources.add(moveAngle(from, to));\n    dests.set(s.dest, sources);\n  }\n  const shapes: SyncableShape[] = d.shapes.concat(nonPieceAutoShapes).map((s: DrawShape) => {\n    return {\n      shape: s,\n      current: false,\n      hash: shapeHash(s, isShort(s.dest, dests), false, bounds),\n    };\n  });\n  if (cur)\n    shapes.push({\n      shape: cur,\n      current: true,\n      hash: shapeHash(cur, isShort(cur.dest, dests), true, bounds),\n    });\n\n  const fullHash = shapes.map(sc => sc.hash).join(';');\n  if (fullHash === state.drawable.prevSvgHash) return;\n  state.drawable.prevSvgHash = fullHash;\n\n  /*\n    -- DOM hierarchy --\n    <svg class=\"cg-shapes\">      (<= svg)\n      <defs>\n        ...(for brushes)...\n      </defs>\n      <g>\n        ...(for arrows and circles)...\n      </g>\n    </svg>\n    <svg class=\"cg-custom-svgs\"> (<= customSvg)\n      <g>\n        ...(for custom svgs)...\n      </g>\n    </svg>\n  */\n\n  const defsEl = shapesEl.querySelector('defs') as SVGElement;\n\n  syncDefs(d, shapes, defsEl);\n  syncShapes(shapes, shapesEl.querySelector('g')!, customsEl.querySelector('g')!, s =>\n    renderShape(state, s, d.brushes, dests, bounds),\n  );\n}\n\n// append only. Don't try to update/remove.\nfunction syncDefs(d: Drawable, shapes: SyncableShape[], defsEl: SVGElement) {\n  const brushes: CustomBrushes = new Map();\n  let brush: DrawBrush;\n  for (const s of shapes.filter(s => s.shape.dest && s.shape.brush)) {\n    brush = makeCustomBrush(d.brushes[s.shape.brush!], s.shape.modifiers);\n    if (s.shape.modifiers?.hilite) brushes.set(hilite(brush).key, hilite(brush));\n    brushes.set(brush.key, brush);\n  }\n  const keysInDom = new Set();\n  let el: SVGElement | undefined = defsEl.firstElementChild as SVGElement;\n  while (el) {\n    keysInDom.add(el.getAttribute('cgKey'));\n    el = el.nextElementSibling as SVGElement | undefined;\n  }\n  for (const [key, brush] of brushes.entries()) {\n    if (!keysInDom.has(key)) defsEl.appendChild(renderMarker(brush));\n  }\n}\n\nfunction syncShapes(\n  syncables: SyncableShape[],\n  shapes: Element,\n  customs: Element,\n  renderShape: (shape: SyncableShape) => Svg[],\n): void {\n  const hashesInDom = new Map();\n\n  for (const sc of syncables) hashesInDom.set(sc.hash, false);\n  for (const root of [shapes, customs]) {\n    const toRemove: SVGElement[] = [];\n    let el: SVGElement | undefined = root.firstElementChild as SVGElement,\n      elHash: Hash | null;\n    while (el) {\n      elHash = el.getAttribute('cgHash') as Hash;\n      if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n      else toRemove.push(el);\n      el = el.nextElementSibling as SVGElement | undefined;\n    }\n    for (const el of toRemove) root.removeChild(el);\n  }\n  // insert shapes that are not yet in dom\n  for (const sc of syncables.filter(s => !hashesInDom.get(s.hash))) {\n    for (const svg of renderShape(sc)) {\n      if (svg.isCustom) customs.appendChild(svg.el);\n      else shapes.appendChild(svg.el);\n    }\n  }\n}\n\nfunction shapeHash(\n  { orig, dest, brush, piece, modifiers, customSvg, label }: DrawShape,\n  shorten: boolean,\n  current: boolean,\n  bounds: DOMRectReadOnly,\n): Hash {\n  // a shape and an overlay svg share a lifetime and have the same cgHash attribute\n  return [\n    bounds.width,\n    bounds.height,\n    current,\n    orig,\n    dest,\n    brush,\n    shorten && '-',\n    piece && pieceHash(piece),\n    modifiers && modifiersHash(modifiers),\n    customSvg && `custom-${textHash(customSvg.html)},${customSvg.center?.[0] ?? 'o'}`,\n    label && `label-${textHash(label.text)}`,\n  ]\n    .filter(x => x)\n    .join(',');\n}\n\nfunction pieceHash(piece: DrawShapePiece): Hash {\n  return [piece.color, piece.role, piece.scale].filter(x => x).join(',');\n}\n\nfunction modifiersHash(m: DrawModifiers): Hash {\n  return [m.lineWidth, m.hilite && '*'].filter(x => x).join(',');\n}\n\nfunction textHash(s: string): Hash {\n  // Rolling hash with base 31 (cf. https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript)\n  let h = 0;\n  for (let i = 0; i < s.length; i++) {\n    h = ((h << 5) - h + s.charCodeAt(i)) >>> 0;\n  }\n  return h.toString();\n}\n\nfunction renderShape(\n  state: State,\n  { shape, current, hash }: SyncableShape,\n  brushes: DrawBrushes,\n  dests: ArrowDests,\n  bounds: DOMRectReadOnly,\n): Svg[] {\n  const from = pos2user(orient(key2pos(shape.orig), state.orientation), bounds),\n    to = shape.dest ? pos2user(orient(key2pos(shape.dest), state.orientation), bounds) : from,\n    brush = shape.brush && makeCustomBrush(brushes[shape.brush], shape.modifiers),\n    slots = dests.get(shape.dest),\n    svgs: Svg[] = [];\n\n  if (brush) {\n    const el = setAttributes(createElement('g'), { cgHash: hash });\n    svgs.push({ el });\n\n    if (from[0] !== to[0] || from[1] !== to[1])\n      el.appendChild(renderArrow(shape, brush, from, to, current, isShort(shape.dest, dests)));\n    else el.appendChild(renderCircle(brushes[shape.brush!], from, current, bounds));\n  }\n  if (shape.label) {\n    const label = shape.label;\n    label.fill ??= shape.brush && brushes[shape.brush].color;\n    const corner = shape.brush ? undefined : 'tr';\n    svgs.push({ el: renderLabel(label, hash, from, to, slots, corner), isCustom: true });\n  }\n  if (shape.customSvg) {\n    const on = shape.customSvg.center ?? 'orig';\n    const [x, y] =\n      on === 'label' ? labelCoords(from, to, slots).map(c => c - 0.5) : on === 'dest' ? to : from;\n    const el = setAttributes(createElement('g'), { transform: `translate(${x},${y})`, cgHash: hash });\n    el.innerHTML = `<svg width=\"1\" height=\"1\" viewBox=\"0 0 100 100\">${shape.customSvg.html}</svg>`;\n    svgs.push({ el, isCustom: true });\n  }\n  return svgs;\n}\n\nfunction renderCircle(\n  brush: DrawBrush,\n  at: cg.NumberPair,\n  current: boolean,\n  bounds: DOMRectReadOnly,\n): SVGElement {\n  const widths = circleWidth(),\n    radius = (bounds.width + bounds.height) / (4 * Math.max(bounds.width, bounds.height));\n  return setAttributes(createElement('circle'), {\n    stroke: brush.color,\n    'stroke-width': widths[current ? 0 : 1],\n    fill: 'none',\n    opacity: opacity(brush, current),\n    cx: at[0],\n    cy: at[1],\n    r: radius - widths[1] / 2,\n  });\n}\n\nfunction hilite(brush: DrawBrush): DrawBrush {\n  return ['#ffffff', '#fff', 'white'].includes(brush.color)\n    ? hilites['hilitePrimary']\n    : hilites['hiliteWhite'];\n}\n\nfunction renderArrow(\n  s: DrawShape,\n  brush: DrawBrush,\n  from: cg.NumberPair,\n  to: cg.NumberPair,\n  current: boolean,\n  shorten: boolean,\n): SVGElement {\n  function renderLine(isHilite: boolean) {\n    const m = arrowMargin(shorten && !current),\n      dx = to[0] - from[0],\n      dy = to[1] - from[1],\n      angle = Math.atan2(dy, dx),\n      xo = Math.cos(angle) * m,\n      yo = Math.sin(angle) * m;\n    return setAttributes(createElement('line'), {\n      stroke: isHilite ? hilite(brush).color : brush.color,\n      'stroke-width': lineWidth(brush, current) + (isHilite ? 0.04 : 0),\n      'stroke-linecap': 'round',\n      'marker-end': `url(#arrowhead-${isHilite ? hilite(brush).key : brush.key})`,\n      opacity: s.modifiers?.hilite ? 1 : opacity(brush, current),\n      x1: from[0],\n      y1: from[1],\n      x2: to[0] - xo,\n      y2: to[1] - yo,\n    });\n  }\n  if (!s.modifiers?.hilite) return renderLine(false);\n\n  const g = createElement('g');\n  const blurred = setAttributes(createElement('g'), { filter: 'url(#cg-filter-blur)' });\n  blurred.appendChild(filterBox(from, to));\n  blurred.appendChild(renderLine(true));\n  g.appendChild(blurred);\n  g.appendChild(renderLine(false));\n  return g;\n}\n\nfunction renderMarker(brush: DrawBrush): SVGElement {\n  const marker = setAttributes(createElement('marker'), {\n    id: 'arrowhead-' + brush.key,\n    orient: 'auto',\n    overflow: 'visible',\n    markerWidth: 4,\n    markerHeight: 4,\n    refX: brush.key.startsWith('hilite') ? 1.86 : 2.05,\n    refY: 2,\n  });\n  marker.appendChild(\n    setAttributes(createElement('path'), {\n      d: 'M0,0 V4 L3,2 Z',\n      fill: brush.color,\n    }),\n  );\n  marker.setAttribute('cgKey', brush.key);\n  return marker;\n}\n\nfunction renderLabel(\n  label: { text: string; fill?: string },\n  hash: string,\n  from: cg.NumberPair,\n  to: cg.NumberPair,\n  slots?: AngleSlots,\n  corner?: 'tr',\n): SVGElement {\n  const labelSize = 0.4,\n    fontSize = labelSize * 0.75 ** label.text.length,\n    at = labelCoords(from, to, slots),\n    cornerOff = corner === 'tr' ? 0.4 : 0,\n    g = setAttributes(createElement('g'), {\n      transform: `translate(${at[0] + cornerOff},${at[1] - cornerOff})`,\n      cgHash: hash,\n    });\n  g.appendChild(\n    setAttributes(createElement('circle'), {\n      r: labelSize / 2,\n      'fill-opacity': corner ? 1.0 : 0.8,\n      'stroke-opacity': corner ? 1.0 : 0.7,\n      'stroke-width': 0.03,\n      fill: label.fill ?? '#666',\n      stroke: 'white',\n    }),\n  );\n  const labelEl = setAttributes(createElement('text'), {\n    'font-size': fontSize,\n    'font-family': 'Noto Sans',\n    'text-anchor': 'middle',\n    fill: 'white',\n    y: 0.13 * 0.75 ** label.text.length,\n  });\n  labelEl.innerHTML = label.text;\n  g.appendChild(labelEl);\n  return g;\n}\n\nfunction orient(pos: cg.Pos, color: cg.Color): cg.Pos {\n  return color === 'white' ? pos : [7 - pos[0], 7 - pos[1]];\n}\n\nfunction isShort(dest: cg.Key | undefined, dests: ArrowDests) {\n  return true === (dest && dests.has(dest) && dests.get(dest)!.size > 1);\n}\n\nfunction createElement(tagName: string): SVGElement {\n  return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n}\n\nfunction setAttributes(el: SVGElement, attrs: { [key: string]: any }): SVGElement {\n  for (const key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) el.setAttribute(key, attrs[key]);\n  }\n  return el;\n}\n\nfunction makeCustomBrush(base: DrawBrush, modifiers: DrawModifiers | undefined): DrawBrush {\n  return !modifiers\n    ? base\n    : {\n        color: base.color,\n        opacity: Math.round(base.opacity * 10) / 10,\n        lineWidth: Math.round(modifiers.lineWidth || base.lineWidth),\n        key: [base.key, modifiers.lineWidth].filter(x => x).join(''),\n      };\n}\n\nfunction circleWidth(): [number, number] {\n  return [3 / 64, 4 / 64];\n}\n\nfunction lineWidth(brush: DrawBrush, current: boolean): number {\n  return ((brush.lineWidth || 10) * (current ? 0.85 : 1)) / 64;\n}\n\nfunction opacity(brush: DrawBrush, current: boolean): number {\n  return (brush.opacity || 1) * (current ? 0.9 : 1);\n}\n\nfunction arrowMargin(shorten: boolean): number {\n  return (shorten ? 20 : 10) / 64;\n}\n\nfunction pos2user(pos: cg.Pos, bounds: DOMRectReadOnly): cg.NumberPair {\n  const xScale = Math.min(1, bounds.width / bounds.height);\n  const yScale = Math.min(1, bounds.height / bounds.width);\n  return [(pos[0] - 3.5) * xScale, (3.5 - pos[1]) * yScale];\n}\n\nfunction filterBox(from: cg.NumberPair, to: cg.NumberPair): SVGElement {\n  // lines/arrows are considered to be one dimensional for the purposes of SVG filters,\n  // so we add a transparent bounding box to ensure they apply to the 2nd dimension\n  const box = {\n    from: [Math.floor(Math.min(from[0], to[0])), Math.floor(Math.min(from[1], to[1]))],\n    to: [Math.ceil(Math.max(from[0], to[0])), Math.ceil(Math.max(from[1], to[1]))],\n  };\n  return setAttributes(createElement('rect'), {\n    x: box.from[0],\n    y: box.from[1],\n    width: box.to[0] - box.from[0],\n    height: box.to[1] - box.from[1],\n    fill: 'none',\n    stroke: 'none',\n  });\n}\n\nfunction moveAngle(from: cg.NumberPair, to: cg.NumberPair, asSlot = true) {\n  const angle = Math.atan2(to[1] - from[1], to[0] - from[0]) + Math.PI;\n  return asSlot ? (Math.round((angle * 8) / Math.PI) + 16) % 16 : angle;\n}\n\nfunction dist(from: cg.NumberPair, to: cg.NumberPair): number {\n  return Math.sqrt([from[0] - to[0], from[1] - to[1]].reduce((acc, x) => acc + x * x, 0));\n}\n\n/*\n try to place label at the junction of the destination shaft and arrowhead. if there's more than\n 1 arrow pointing to a square, the arrow shortens by 10 / 64 units so the label must move as well. \n \n if the angle between two incoming arrows is pi / 8, such as when an adjacent knight and bishop\n attack the same square, the knight's label is slid further down the shaft by an amount equal to\n our label size to avoid collision\n*/\n\nfunction labelCoords(from: cg.NumberPair, to: cg.NumberPair, slots?: AngleSlots): cg.NumberPair {\n  let mag = dist(from, to);\n  //if (mag === 0) return [from[0], from[1]];\n  const angle = moveAngle(from, to, false);\n  if (slots) {\n    mag -= 33 / 64; // reduce by arrowhead length\n    if (slots.size > 1) {\n      mag -= 10 / 64; // reduce by shortening factor\n      const slot = moveAngle(from, to);\n      if (slots.has((slot + 1) % 16) || slots.has((slot + 15) % 16)) {\n        if (slot & 1) mag -= 0.4;\n        // and by label size for the knight if another arrow is within pi / 8.\n      }\n    }\n  }\n  return [from[0] - Math.cos(angle) * mag, from[1] - Math.sin(angle) * mag].map(\n    c => c + 0.5,\n  ) as cg.NumberPair;\n}\n", "import { HeadlessState } from './state.js';\nimport { setVisible, createEl } from './util.js';\nimport { colors, files, ranks, Elements } from './types.js';\nimport { createElement as createSVG, setAttributes, createDefs } from './svg.js';\n\nexport function renderWrap(element: HTMLElement, s: HeadlessState): Elements {\n  // .cg-wrap (element passed to Chessground)\n  //   cg-container\n  //     cg-board\n  //     svg.cg-shapes\n  //       defs\n  //       g\n  //     svg.cg-custom-svgs\n  //       g\n  //     cg-auto-pieces\n  //     coords.ranks\n  //     coords.files\n  //     piece.ghost\n\n  element.innerHTML = '';\n\n  // ensure the cg-wrap class is set\n  // so bounds calculation can use the CSS width/height values\n  // add that class yourself to the element before calling chessground\n  // for a slight performance improvement! (avoids recomputing style)\n  element.classList.add('cg-wrap');\n\n  for (const c of colors) element.classList.toggle('orientation-' + c, s.orientation === c);\n  element.classList.toggle('manipulable', !s.viewOnly);\n\n  const container = createEl('cg-container');\n  element.appendChild(container);\n\n  const board = createEl('cg-board');\n  container.appendChild(board);\n\n  let svg: SVGElement | undefined;\n  let customSvg: SVGElement | undefined;\n  let autoPieces: HTMLElement | undefined;\n\n  if (s.drawable.visible) {\n    svg = setAttributes(createSVG('svg'), {\n      class: 'cg-shapes',\n      viewBox: '-4 -4 8 8',\n      preserveAspectRatio: 'xMidYMid slice',\n    });\n    svg.appendChild(createDefs());\n    svg.appendChild(createSVG('g'));\n\n    customSvg = setAttributes(createSVG('svg'), {\n      class: 'cg-custom-svgs',\n      viewBox: '-3.5 -3.5 8 8',\n      preserveAspectRatio: 'xMidYMid slice',\n    });\n    customSvg.appendChild(createSVG('g'));\n\n    autoPieces = createEl('cg-auto-pieces');\n\n    container.appendChild(svg);\n    container.appendChild(customSvg);\n    container.appendChild(autoPieces);\n  }\n\n  if (s.coordinates) {\n    const orientClass = s.orientation === 'black' ? ' black' : '';\n    const ranksPositionClass = s.ranksPosition === 'left' ? ' left' : '';\n\n    if (s.coordinatesOnSquares) {\n      const rankN: (i: number) => number = s.orientation === 'white' ? i => i + 1 : i => 8 - i;\n      files.forEach((f, i) =>\n        container.appendChild(\n          renderCoords(\n            ranks.map(r => f + r),\n            'squares rank' + rankN(i) + orientClass + ranksPositionClass,\n          ),\n        ),\n      );\n    } else {\n      container.appendChild(renderCoords(ranks, 'ranks' + orientClass + ranksPositionClass));\n      container.appendChild(renderCoords(files, 'files' + orientClass));\n    }\n  }\n\n  let ghost: HTMLElement | undefined;\n  if (s.draggable.enabled && s.draggable.showGhost) {\n    ghost = createEl('piece', 'ghost');\n    setVisible(ghost, false);\n    container.appendChild(ghost);\n  }\n\n  return {\n    board,\n    container,\n    wrap: element,\n    ghost,\n    svg,\n    customSvg,\n    autoPieces,\n  };\n}\n\nfunction renderCoords(elems: readonly string[], className: string): HTMLElement {\n  const el = createEl('coords', className);\n  let f: HTMLElement;\n  for (const elem of elems) {\n    f = createEl('coord');\n    f.textContent = elem;\n    el.appendChild(f);\n  }\n  return el;\n}\n", "import { State } from './state.js';\nimport * as cg from './types.js';\nimport * as board from './board.js';\nimport * as util from './util.js';\nimport { cancel as dragCancel } from './drag.js';\n\nexport function setDropMode(s: State, piece?: cg.Piece): void {\n  s.dropmode = {\n    active: true,\n    piece,\n  };\n  dragCancel(s);\n}\n\nexport function cancelDropMode(s: State): void {\n  s.dropmode = {\n    active: false,\n  };\n}\n\nexport function drop(s: State, e: cg.MouchEvent): void {\n  if (!s.dropmode.active) return;\n\n  board.unsetPremove(s);\n  board.unsetPredrop(s);\n\n  const piece = s.dropmode.piece;\n\n  if (piece) {\n    s.pieces.set('a0', piece);\n    const position = util.eventPosition(e);\n    const dest = position && board.getKeyAtDomPos(position, board.whitePov(s), s.dom.bounds());\n    if (dest) board.dropNewPiece(s, 'a0', dest);\n  }\n  s.dom.redraw();\n}\n", "import { State } from './state.js';\nimport * as drag from './drag.js';\nimport * as draw from './draw.js';\nimport { drop } from './drop.js';\nimport { isRightButton } from './util.js';\nimport * as cg from './types.js';\n\ntype MouchBind = (e: cg.MouchEvent) => void;\ntype StateMouchBind = (d: State, e: cg.MouchEvent) => void;\n\nexport function bindBoard(s: State, onResize: () => void): void {\n  const boardEl = s.dom.elements.board;\n\n  if ('ResizeObserver' in window) new ResizeObserver(onResize).observe(s.dom.elements.wrap);\n\n  if (s.disableContextMenu || s.drawable.enabled) {\n    boardEl.addEventListener('contextmenu', e => e.preventDefault());\n  }\n\n  if (s.viewOnly) return;\n\n  // Cannot be passive, because we prevent touch scrolling and dragging of\n  // selected elements.\n  const onStart = startDragOrDraw(s);\n  boardEl.addEventListener('touchstart', onStart as EventListener, {\n    passive: false,\n  });\n  boardEl.addEventListener('mousedown', onStart as EventListener, {\n    passive: false,\n  });\n}\n\n// returns the unbind function\nexport function bindDocument(s: State, onResize: () => void): cg.Unbind {\n  const unbinds: cg.Unbind[] = [];\n\n  // Old versions of Edge and Safari do not support ResizeObserver. Send\n  // chessground.resize if a user action has changed the bounds of the board.\n  if (!('ResizeObserver' in window)) unbinds.push(unbindable(document.body, 'chessground.resize', onResize));\n\n  if (!s.viewOnly) {\n    const onmove = dragOrDraw(s, drag.move, draw.move);\n    const onend = dragOrDraw(s, drag.end, draw.end);\n\n    for (const ev of ['touchmove', 'mousemove'])\n      unbinds.push(unbindable(document, ev, onmove as EventListener));\n    for (const ev of ['touchend', 'mouseup']) unbinds.push(unbindable(document, ev, onend as EventListener));\n\n    const onScroll = () => s.dom.bounds.clear();\n    unbinds.push(unbindable(document, 'scroll', onScroll, { capture: true, passive: true }));\n    unbinds.push(unbindable(window, 'resize', onScroll, { passive: true }));\n  }\n\n  return () => unbinds.forEach(f => f());\n}\n\nfunction unbindable(\n  el: EventTarget,\n  eventName: string,\n  callback: EventListener,\n  options?: AddEventListenerOptions,\n): cg.Unbind {\n  el.addEventListener(eventName, callback, options);\n  return () => el.removeEventListener(eventName, callback, options);\n}\n\nconst startDragOrDraw =\n  (s: State): MouchBind =>\n  e => {\n    if (s.draggable.current) drag.cancel(s);\n    else if (s.drawable.current) draw.cancel(s);\n    else if (e.shiftKey || isRightButton(e)) {\n      if (s.drawable.enabled) draw.start(s, e);\n    } else if (!s.viewOnly) {\n      if (s.dropmode.active) drop(s, e);\n      else drag.start(s, e);\n    }\n  };\n\nconst dragOrDraw =\n  (s: State, withDrag: StateMouchBind, withDraw: StateMouchBind): MouchBind =>\n  e => {\n    if (s.drawable.current) {\n      if (s.drawable.enabled) withDraw(s, e);\n    } else if (!s.viewOnly) withDrag(s, e);\n  };\n", "import { State } from './state.js';\nimport { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translate } from './util.js';\nimport { whitePov } from './board.js';\nimport { AnimCurrent, AnimVectors, AnimVector, AnimFadings } from './anim.js';\nimport { DragCurrent } from './drag.js';\nimport * as cg from './types.js';\n\ntype PieceName = string; // `$color $role`\n\n// ported from https://github.com/lichess-org/lichobile/blob/master/src/chessground/render.ts\n// in case of bugs, blame @veloce\nexport function render(s: State): void {\n  const asWhite: boolean = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds()),\n    boardEl: HTMLElement = s.dom.elements.board,\n    pieces: cg.Pieces = s.pieces,\n    curAnim: AnimCurrent | undefined = s.animation.current,\n    anims: AnimVectors = curAnim ? curAnim.plan.anims : new Map(),\n    fadings: AnimFadings = curAnim ? curAnim.plan.fadings : new Map(),\n    curDrag: DragCurrent | undefined = s.draggable.current,\n    squares: cg.SquareClasses = computeSquareClasses(s),\n    samePieces: Set<cg.Key> = new Set(),\n    sameSquares: Set<cg.Key> = new Set(),\n    movedPieces: Map<PieceName, cg.PieceNode[]> = new Map(),\n    movedSquares: Map<string, cg.SquareNode[]> = new Map(); // by class name\n  let k: cg.Key,\n    el: cg.PieceNode | cg.SquareNode | undefined,\n    pieceAtKey: cg.Piece | undefined,\n    elPieceName: PieceName,\n    anim: AnimVector | undefined,\n    fading: cg.Piece | undefined,\n    pMvdset: cg.PieceNode[] | undefined,\n    pMvd: cg.PieceNode | undefined,\n    sMvdset: cg.SquareNode[] | undefined,\n    sMvd: cg.SquareNode | undefined;\n\n  // walk over all board dom elements, apply animations and flag moved pieces\n  el = boardEl.firstChild as cg.PieceNode | cg.SquareNode | undefined;\n  while (el) {\n    k = el.cgKey;\n    if (isPieceNode(el)) {\n      pieceAtKey = pieces.get(k);\n      anim = anims.get(k);\n      fading = fadings.get(k);\n      elPieceName = el.cgPiece;\n      // if piece not being dragged anymore, remove dragging style\n      if (el.cgDragging && (!curDrag || curDrag.orig !== k)) {\n        el.classList.remove('dragging');\n        translate(el, posToTranslate(key2pos(k), asWhite));\n        el.cgDragging = false;\n      }\n      // remove fading class if it still remains\n      if (!fading && el.cgFading) {\n        el.cgFading = false;\n        el.classList.remove('fading');\n      }\n      // there is now a piece at this dom key\n      if (pieceAtKey) {\n        // continue animation if already animating and same piece\n        // (otherwise it could animate a captured piece)\n        if (anim && el.cgAnimating && elPieceName === pieceNameOf(pieceAtKey)) {\n          const pos = key2pos(k);\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n          el.classList.add('anim');\n          translate(el, posToTranslate(pos, asWhite));\n        } else if (el.cgAnimating) {\n          el.cgAnimating = false;\n          el.classList.remove('anim');\n          translate(el, posToTranslate(key2pos(k), asWhite));\n          if (s.addPieceZIndex) el.style.zIndex = posZIndex(key2pos(k), asWhite);\n        }\n        // same piece: flag as same\n        if (elPieceName === pieceNameOf(pieceAtKey) && (!fading || !el.cgFading)) {\n          samePieces.add(k);\n        }\n        // different piece: flag as moved unless it is a fading piece\n        else {\n          if (fading && elPieceName === pieceNameOf(fading)) {\n            el.classList.add('fading');\n            el.cgFading = true;\n          } else {\n            appendValue(movedPieces, elPieceName, el);\n          }\n        }\n      }\n      // no piece: flag as moved\n      else {\n        appendValue(movedPieces, elPieceName, el);\n      }\n    } else if (isSquareNode(el)) {\n      const cn = el.className;\n      if (squares.get(k) === cn) sameSquares.add(k);\n      else appendValue(movedSquares, cn, el);\n    }\n    el = el.nextSibling as cg.PieceNode | cg.SquareNode | undefined;\n  }\n\n  // walk over all squares in current set, apply dom changes to moved squares\n  // or append new squares\n  for (const [sk, className] of squares) {\n    if (!sameSquares.has(sk)) {\n      sMvdset = movedSquares.get(className);\n      sMvd = sMvdset && sMvdset.pop();\n      const translation = posToTranslate(key2pos(sk), asWhite);\n      if (sMvd) {\n        sMvd.cgKey = sk;\n        translate(sMvd, translation);\n      } else {\n        const squareNode = createEl('square', className) as cg.SquareNode;\n        squareNode.cgKey = sk;\n        translate(squareNode, translation);\n        boardEl.insertBefore(squareNode, boardEl.firstChild);\n      }\n    }\n  }\n\n  // walk over all pieces in current set, apply dom changes to moved pieces\n  // or append new pieces\n  for (const [k, p] of pieces) {\n    anim = anims.get(k);\n    if (!samePieces.has(k)) {\n      pMvdset = movedPieces.get(pieceNameOf(p));\n      pMvd = pMvdset && pMvdset.pop();\n      // a same piece was moved\n      if (pMvd) {\n        // apply dom changes\n        pMvd.cgKey = k;\n        if (pMvd.cgFading) {\n          pMvd.classList.remove('fading');\n          pMvd.cgFading = false;\n        }\n        const pos = key2pos(k);\n        if (s.addPieceZIndex) pMvd.style.zIndex = posZIndex(pos, asWhite);\n        if (anim) {\n          pMvd.cgAnimating = true;\n          pMvd.classList.add('anim');\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pMvd, posToTranslate(pos, asWhite));\n      }\n      // no piece in moved obj: insert the new piece\n      // assumes the new piece is not being dragged\n      else {\n        const pieceName = pieceNameOf(p),\n          pieceNode = createEl('piece', pieceName) as cg.PieceNode,\n          pos = key2pos(k);\n\n        pieceNode.cgPiece = pieceName;\n        pieceNode.cgKey = k;\n        if (anim) {\n          pieceNode.cgAnimating = true;\n          pos[0] += anim[2];\n          pos[1] += anim[3];\n        }\n        translate(pieceNode, posToTranslate(pos, asWhite));\n\n        if (s.addPieceZIndex) pieceNode.style.zIndex = posZIndex(pos, asWhite);\n\n        boardEl.appendChild(pieceNode);\n      }\n    }\n  }\n\n  // remove any element that remains in the moved sets\n  for (const nodes of movedPieces.values()) removeNodes(s, nodes);\n  for (const nodes of movedSquares.values()) removeNodes(s, nodes);\n}\n\nexport function renderResized(s: State): void {\n  const asWhite: boolean = whitePov(s),\n    posToTranslate = posToTranslateFromBounds(s.dom.bounds());\n  let el = s.dom.elements.board.firstChild as cg.PieceNode | cg.SquareNode | undefined;\n  while (el) {\n    if ((isPieceNode(el) && !el.cgAnimating) || isSquareNode(el)) {\n      translate(el, posToTranslate(key2pos(el.cgKey), asWhite));\n    }\n    el = el.nextSibling as cg.PieceNode | cg.SquareNode | undefined;\n  }\n}\n\nexport function updateBounds(s: State): void {\n  const bounds = s.dom.elements.wrap.getBoundingClientRect();\n  const container = s.dom.elements.container;\n  const ratio = bounds.height / bounds.width;\n  const width = (Math.floor((bounds.width * window.devicePixelRatio) / 8) * 8) / window.devicePixelRatio;\n  const height = width * ratio;\n  container.style.width = width + 'px';\n  container.style.height = height + 'px';\n  s.dom.bounds.clear();\n\n  s.addDimensionsCssVarsTo?.style.setProperty('---cg-width', width + 'px');\n  s.addDimensionsCssVarsTo?.style.setProperty('---cg-height', height + 'px');\n}\n\nconst isPieceNode = (el: cg.PieceNode | cg.SquareNode): el is cg.PieceNode => el.tagName === 'PIECE';\nconst isSquareNode = (el: cg.PieceNode | cg.SquareNode): el is cg.SquareNode => el.tagName === 'SQUARE';\n\nfunction removeNodes(s: State, nodes: HTMLElement[]): void {\n  for (const node of nodes) s.dom.elements.board.removeChild(node);\n}\n\nfunction posZIndex(pos: cg.Pos, asWhite: boolean): string {\n  const minZ = 3;\n  const rank = pos[1];\n  const z = asWhite ? minZ + 7 - rank : minZ + rank;\n\n  return `${z}`;\n}\n\nconst pieceNameOf = (piece: cg.Piece): string => `${piece.color} ${piece.role}`;\n\nfunction computeSquareClasses(s: State): cg.SquareClasses {\n  const squares: cg.SquareClasses = new Map();\n  if (s.lastMove && s.highlight.lastMove)\n    for (const k of s.lastMove) {\n      addSquare(squares, k, 'last-move');\n    }\n  if (s.check && s.highlight.check) addSquare(squares, s.check, 'check');\n  if (s.selected) {\n    addSquare(squares, s.selected, 'selected');\n    if (s.movable.showDests) {\n      const dests = s.movable.dests?.get(s.selected);\n      if (dests)\n        for (const k of dests) {\n          addSquare(squares, k, 'move-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n      const pDests = s.premovable.customDests?.get(s.selected) ?? s.premovable.dests;\n      if (pDests)\n        for (const k of pDests) {\n          addSquare(squares, k, 'premove-dest' + (s.pieces.has(k) ? ' oc' : ''));\n        }\n    }\n  }\n  const premove = s.premovable.current;\n  if (premove) for (const k of premove) addSquare(squares, k, 'current-premove');\n  else if (s.predroppable.current) addSquare(squares, s.predroppable.current.key, 'current-premove');\n\n  const o = s.exploding;\n  if (o) for (const k of o.keys) addSquare(squares, k, 'exploding' + o.stage);\n\n  if (s.highlight.custom) {\n    s.highlight.custom.forEach((v: string, k: cg.Key) => {\n      addSquare(squares, k, v);\n    });\n  }\n\n  return squares;\n}\n\nfunction addSquare(squares: cg.SquareClasses, key: cg.Key, klass: string): void {\n  const classes = squares.get(key);\n  if (classes) squares.set(key, `${classes} ${klass}`);\n  else squares.set(key, klass);\n}\n\nfunction appendValue<K, V>(map: Map<K, V[]>, key: K, value: V): void {\n  const arr = map.get(key);\n  if (arr) arr.push(value);\n  else map.set(key, [value]);\n}\n", "import { DrawShape } from './draw';\n\nexport interface SyncableShape {\n  shape: DrawShape;\n  current: boolean;\n  hash: Hash;\n}\n\nexport type Hash = string;\n\n// append and remove only. No updates.\nexport function syncShapes(\n  shapes: SyncableShape[],\n  root: HTMLElement | SVGElement,\n  renderShape: (shape: SyncableShape) => HTMLElement | SVGElement,\n): void {\n  const hashesInDom = new Map(), // by hash\n    toRemove: SVGElement[] = [];\n  for (const sc of shapes) hashesInDom.set(sc.hash, false);\n  let el: SVGElement | undefined = root.firstElementChild as SVGElement,\n    elHash: Hash | null;\n  while (el) {\n    elHash = el.getAttribute('cgHash') as Hash;\n    // found a shape element that's here to stay\n    if (hashesInDom.has(elHash)) hashesInDom.set(elHash, true);\n    // or remove it\n    else toRemove.push(el);\n    el = el.nextElementSibling as SVGElement | undefined;\n  }\n  // remove old shapes\n  for (const el of toRemove) root.removeChild(el);\n  // insert shapes that are not yet in dom\n  for (const sc of shapes) {\n    if (!hashesInDom.get(sc.hash)) root.appendChild(renderShape(sc));\n  }\n}\n", "import { State } from './state.js';\nimport { key2pos, createEl, posToTranslate as posToTranslateFromBounds, translateAndScale } from './util.js';\nimport { whitePov } from './board.js';\nimport * as cg from './types.js';\nimport { DrawShape } from './draw.js';\nimport { SyncableShape, Hash, syncShapes } from './sync.js';\n\nexport function render(state: State, autoPieceEl: HTMLElement): void {\n  const autoPieces = state.drawable.autoShapes.filter(autoShape => autoShape.piece);\n  const autoPieceShapes: SyncableShape[] = autoPieces.map((s: DrawShape) => {\n    return {\n      shape: s,\n      hash: hash(s),\n      current: false,\n    };\n  });\n\n  syncShapes(autoPieceShapes, autoPieceEl, shape => renderShape(state, shape, state.dom.bounds()));\n}\n\nexport function renderResized(state: State): void {\n  const asWhite: boolean = whitePov(state),\n    posToTranslate = posToTranslateFromBounds(state.dom.bounds());\n  let el = state.dom.elements.autoPieces?.firstChild as cg.PieceNode | undefined;\n  while (el) {\n    translateAndScale(el, posToTranslate(key2pos(el.cgKey), asWhite), el.cgScale);\n    el = el.nextSibling as cg.PieceNode | undefined;\n  }\n}\n\nfunction renderShape(state: State, { shape, hash }: SyncableShape, bounds: DOMRectReadOnly): cg.PieceNode {\n  const orig = shape.orig;\n  const role = shape.piece?.role;\n  const color = shape.piece?.color;\n  const scale = shape.piece?.scale;\n\n  const pieceEl = createEl('piece', `${role} ${color}`) as cg.PieceNode;\n  pieceEl.setAttribute('cgHash', hash);\n  pieceEl.cgKey = orig;\n  pieceEl.cgScale = scale;\n  translateAndScale(pieceEl, posToTranslateFromBounds(bounds)(key2pos(orig), whitePov(state)), scale);\n\n  return pieceEl;\n}\n\nconst hash = (autoPiece: DrawShape): Hash =>\n  [autoPiece.orig, autoPiece.piece?.role, autoPiece.piece?.color, autoPiece.piece?.scale].join(',');\n", "import { Api, start } from './api.js';\nimport { Config, configure } from './config.js';\nimport { HeadlessState, State, defaults } from './state.js';\n\nimport { renderWrap } from './wrap.js';\nimport * as events from './events.js';\nimport { render, renderResized, updateBounds } from './render.js';\nimport * as autoPieces from './autoPieces.js';\nimport * as svg from './svg.js';\nimport * as util from './util.js';\n\nexport function initModule({ el, config }: { el: HTMLElement; config?: Config }): Api {\n  return Chessground(el, config);\n}\n\nexport function Chessground(element: HTMLElement, config?: Config): Api {\n  const maybeState: State | HeadlessState = defaults();\n\n  configure(maybeState, config || {});\n\n  function redrawAll(): State {\n    const prevUnbind = 'dom' in maybeState ? maybeState.dom.unbind : undefined;\n    // compute bounds from existing board element if possible\n    // this allows non-square boards from CSS to be handled (for 3D)\n    const elements = renderWrap(element, maybeState),\n      bounds = util.memo(() => elements.board.getBoundingClientRect()),\n      redrawNow = (skipSvg?: boolean): void => {\n        render(state);\n        if (elements.autoPieces) autoPieces.render(state, elements.autoPieces);\n        if (!skipSvg && elements.svg) svg.renderSvg(state, elements.svg, elements.customSvg!);\n      },\n      onResize = (): void => {\n        updateBounds(state);\n        renderResized(state);\n        if (elements.autoPieces) autoPieces.renderResized(state);\n      };\n    const state = maybeState as State;\n    state.dom = {\n      elements,\n      bounds,\n      redraw: debounceRedraw(redrawNow),\n      redrawNow,\n      unbind: prevUnbind,\n    };\n    state.drawable.prevSvgHash = '';\n    updateBounds(state);\n    redrawNow(false);\n    events.bindBoard(state, onResize);\n    if (!prevUnbind) state.dom.unbind = events.bindDocument(state, onResize);\n    state.events.insert && state.events.insert(elements);\n    return state;\n  }\n\n  return start(redrawAll(), redrawAll);\n}\n\nfunction debounceRedraw(redrawNow: (skipSvg?: boolean) => void): () => void {\n  let redrawing = false;\n  return () => {\n    if (redrawing) return;\n    redrawing = true;\n    requestAnimationFrame(() => {\n      redrawNow();\n      redrawing = false;\n    });\n  };\n}\n"],
  "mappings": "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",
  "names": ["files", "king", "rook", "move", "drop", "king", "now", "start", "cancel", "move", "end", "start", "toggleOrientation", "state", "cancel", "brushes", "s", "brush", "renderShape", "el", "hash", "_a", "move", "end", "cancel", "start", "render", "posToTranslate", "anim", "k", "premove", "syncShapes", "renderShape", "el", "render", "syncShapes", "renderShape", "renderResized", "posToTranslate", "hash", "render", "renderResized", "start"]
}
